---
layout: post
title: ã€æ¼æ´åˆ†æã€‘CVE-2021-0920-Linuxå†…æ ¸åƒåœ¾å›æ”¶æœºåˆ¶ç«äº‰UAF
categories: Kernel-exploit
description: ã€æ¼æ´åˆ†æã€‘CVE-2021-0920-Linuxå†…æ ¸åƒåœ¾å›æ”¶æœºåˆ¶ç«äº‰UAF
keywords: CVE, Kernel, Exploit
---


# ã€æ¼æ´åˆ†æã€‘CVE-2021-0920-Linuxå†…æ ¸åƒåœ¾å›æ”¶æœºåˆ¶ç«äº‰UAF

**æ¼æ´å‘ç°**ï¼šè¯¥æ¼æ´æ—©åœ¨2016å¹´è¢« RedHat å†…æ ¸å¼€å‘äººå‘˜å‘ç°å¹¶æŠ«éœ²ï¼Œä½† Linux å†…æ ¸ç¤¾åŒºç›´åˆ° 2021 å¹´é‡æ–°æŠ¥å‘Šåæ‰å¯¹è¯¥æ¼æ´è¿›è¡Œä¿®è¡¥ï¼ˆ[patch](https://patchwork.ozlabs.org/project/netdev/patch/CAOssrKcfncAYsQWkfLGFgoOxAQJVT2hYVWdBA6Cw7hhO8RJ_wQ@mail.gmail.com/)ï¼‰ã€‚Googleçš„å¨èƒåˆ†æå°ç»„ï¼ˆThreat Analysis Groupï¼‰å‘ç°è¯¥æ¼æ´åœ¨é‡å¤–è¢«ä½¿ç”¨ï¼Œå¯ä»¥ç»•è¿‡æ²™ç®±å’Œææƒï¼Œç»“åˆChromeå’Œä¸‰æ˜Ÿæµè§ˆå™¨æ¼æ´åˆ©ç”¨ï¼Œå°±èƒ½å¤Ÿè¿œç¨‹rootä¸‰æ˜Ÿè®¾å¤‡ã€‚è¢«æ”»å‡»çš„ç›®æ ‡åŒ…æ‹¬ä¸‰æ˜Ÿ S10 å’Œ S20ï¼Œé‡å¤–åˆ©ç”¨æ ·æœ¬èƒ½ç»•è¿‡ `CONFIG_ARM64_UAO`ï¼Œå®ç°ä»»æ„è¯»/å†™åŸè¯­ï¼Œç»•è¿‡ä¸‰æ˜Ÿ RKP æå‡è‡³ rootã€‚

**ä¸»è¦å†…å®¹**ï¼šæœ¬æ–‡åˆ†æäº† `SCM_RIGHTS` çš„å†…æ ¸å®ç°ä»¥åŠ Linux å†…æ ¸åƒåœ¾å›æ”¶å™¨çš„è®¾è®¡å’Œå®ç°ï¼Œæ­¤å¤–ï¼Œè¿˜åˆ†æäº†MSG_PEEK æ ‡å¿—ä¸recvmsgç³»ç»Ÿè°ƒç”¨çš„æ‰§è¡Œæµç¨‹ï¼Œä»¥åŠå¯¼è‡´ç«äº‰è€Œè§¦å‘UAFæ¼æ´çš„è¿‡ç¨‹ã€‚è¯¥æ¼æ´æ—©åœ¨ 2016 å¹´å°±è¢«å‘ç°ï¼Œä½† Linux å†…æ ¸ç¤¾åŒºå½“æ—¶å¹¶æœªæ¥å—è¯¥è¡¥ä¸ï¼Œä»»ä½•äººçœ‹åˆ°è¿™å°å…¬å¼€çš„é‚®ä»¶éƒ½æœ‰å¯èƒ½åˆ©ç”¨è¯¥æ¼æ´æ¥ææƒã€‚

**CVE-2021-0920æ¼æ´åŸç†**ï¼šCVE-2021-0920 æ˜¯ç”±äº `SCM_RIGHTS` çš„åƒåœ¾å›æ”¶ç³»ç»Ÿï¼ˆGarbage Collectionï¼‰ä¸­çš„ç«äº‰æ¡ä»¶è€Œå¯¼è‡´çš„UAFã€‚`SCM_RIGHTS` æ˜¯ä¸€ç§æ§åˆ¶æ¶ˆæ¯ï¼Œå®ƒå…è®¸ unix socket**å°†æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ä»ä¸€ä¸ªè¿›ç¨‹ä¼ è¾“åˆ°å¦ä¸€ä¸ªè¿›ç¨‹**ã€‚æ¢å¥è¯è¯´ï¼Œsenderå‘é€æ–‡ä»¶æè¿°ç¬¦ï¼Œç„¶å receiver ä» sender è·å–æ–‡ä»¶æè¿°ç¬¦ã€‚è¿™ç§æ–‡ä»¶æè¿°ç¬¦çš„ä¼ é€’å¢åŠ äº† `file` ç»“æ„å¼•ç”¨è®¡æ•°çš„å¤æ‚æ€§ã€‚ä¸ºäº†è§£å†³è¯¥é—®é¢˜ï¼ŒLinux å†…æ ¸è®¾è®¡äº†ä¸€ä¸ªç‰¹æ®Šçš„åƒåœ¾å›æ”¶ç³»ç»Ÿã€‚CVE-2021-0920 æ˜¯æ­¤åƒåœ¾å›æ”¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªæ¼æ´ã€‚**é€šè¿‡åœ¨åƒåœ¾å›æ”¶è¿‡ç¨‹ä¸­èµ¢å¾—ç«äº‰æ¡ä»¶ï¼Œæ”»å‡»è€…å¯ä»¥è·å¾—socketç¼“å†²åŒºä¸Šä¹Ÿå³`sk_buff`å¯¹è±¡çš„ UAF**ã€‚æ¥ä¸‹æ¥ï¼Œå°†è¯¦ç»†ä»‹ç» `SCM_RIGHTS` åƒåœ¾å›æ”¶ç³»ç»Ÿå’Œæ¼æ´åŸç†ï¼Œæœ¬æ–‡åŸºäºLinux 4.14 å†…æ ¸ã€‚

## 1. UNIX_GCåƒåœ¾å›æ”¶æœºåˆ¶ä»‹ç»

### 1-1. `file` ç»“æ„å¼•ç”¨è®¡æ•°

**`file`ç»“æ„**ï¼šLinux å†…æ ¸ä½¿ç”¨ [file](https://elixir.bootlin.com/linux/v5.0-rc6/source/include/linux/fs.h#L901) ç»“æ„æ¥è¡¨ç¤ºä¸€ä¸ªæ‰“å¼€çš„æ–‡ä»¶ï¼Œç”¨æˆ·ç©ºé—´æ¯æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼Œå†…æ ¸å°±ä¼šåˆ›å»ºä¸€ä¸ªç›¸åº”çš„`file`ç»“æ„ä½“ã€‚æœ¬è´¨ä¸Šï¼Œæ–‡ä»¶æè¿°ç¬¦å°±æ˜¯ä¸€ä¸ªç´¢å¼•ï¼Œå¯é€šè¿‡ [struct files_struct](https://elixir.bootlin.com/linux/v5.0-rc6/source/include/linux/fdtable.h#L48) ä¸­çš„ `file` æŒ‡é’ˆæ•°ç»„ï¼ˆ`files_struct->fd_array`ï¼‰æ¥æ‰¾åˆ°å¯¹åº”çš„ `file` ç»“æ„æŒ‡é’ˆã€‚`file` ç»“æ„ä¸­ä¿å­˜äº†å¤§é‡ä¿¡æ¯ ï¼ŒåŒ…æ‹¬æ–‡ä»¶ä¸­çš„å½“å‰ä½ç½®ã€è®¿é—®æ¨¡å¼ã€[`file_operations`](https://elixir.bootlin.com/linux/v5.0-rc6/source/include/linux/fs.h#L1782) ç»“æ„ã€ä¾›åº•å±‚ä»£ç ä½¿ç”¨çš„ `private_data` æŒ‡é’ˆç­‰ã€‚

**å¼•ç”¨è®¡æ•°**ï¼šå’Œå…¶ä»–å†…æ ¸ç»“æ„ä¸€æ ·ï¼Œå¯ä»¥å­˜åœ¨å¤šä¸ªå¯¹`file` ç»“æ„çš„å¼•ç”¨ã€‚ä¾‹å¦‚ï¼Œå°†æ–‡ä»¶æè¿°ç¬¦ä¼ ç»™ [dup()](http://man7.org/linux/man-pages/man2/dup.2.html) å°†åˆ†é…æŒ‡å‘ç›¸åŒ `file` ç»“æ„çš„ç¬¬2ä¸ªæ–‡ä»¶æè¿°ç¬¦ã€‚**å†…æ ¸ç”¨ `file->f_count` æˆå‘˜æ¥è®°å½•å…¶å¼•ç”¨æ•°ç›®**ï¼Œå¦‚æœæŸ `file` ç»“æ„ä¸å†è¢«ä½¿ç”¨åˆ™å°†å…¶é‡Šæ”¾ã€‚åªè¦ä½¿ç”¨äº†è¯¥æ–‡ä»¶ï¼ˆåˆ›å»ºå¼•ç”¨ï¼Œä¾‹å¦‚è°ƒç”¨ `dup()` å¤åˆ¶æ–‡ä»¶æè¿°ç¬¦ã€forkæ–°è¿›ç¨‹ã€å¼€å§‹è¿›è¡ŒI/Oæ“ä½œï¼‰å°±å¢åŠ  `file->f_count` å¼•ç”¨è®¡æ•°ï¼›ä½¿ç”¨å®Œä¹‹åç§»é™¤å¼•ç”¨å¯é€šè¿‡è°ƒç”¨ `close()` / `exit()`ï¼Œå°±å‡å°‘ `file->f_count` å¼•ç”¨è®¡æ•°ï¼›å½“å¼•ç”¨è®¡æ•°ä¸º0æ—¶ï¼Œé‡Šæ”¾è¯¥ `file` ç»“æ„ã€‚

å†…æ ¸ä¸­å¾ˆå¤šæ“ä½œéƒ½èƒ½åˆ›å»ºå¯¹`file` ç»“æ„çš„å¼•ç”¨ï¼Œä¾‹å¦‚ï¼Œè°ƒç”¨`read()`å°†åœ¨æ“ä½œæœŸé—´ä¿å­˜ä¸€ä¸ªå¼•ç”¨ï¼Œä»¥ç¡®ä¿`file`ç»“æ„ä¸€ç›´å­˜åœ¨ï¼›mountæŒ‚è½½ `file` ä¸­çš„æ–‡ä»¶ç³»ç»Ÿå°†åˆ›å»ºä¸€ä¸ªå¼•ç”¨ï¼Œç›´åˆ°unmountå¸è½½æ–‡ä»¶ç³»ç»Ÿã€‚è¿˜åŒ…æ‹¬åé¢ä»‹ç»çš„é€šè¿‡sockçš„scmåŠŸèƒ½å‘é€æ–‡ä»¶ç»™å¦ä¸€ç«¯/io_uringçš„æ³¨å†Œæ–‡ä»¶ç­‰ã€‚

å®é™…èƒ½å¼•èµ·æ–‡ä»¶å¼•ç”¨è®¡æ•°å˜åŒ–çš„å†…æ ¸å‡½æ•°æœ‰ï¼š

- `fget()`ï¼šé€šè¿‡æ–‡ä»¶æè¿°ç¬¦è·å– `struct file`ï¼Œå¹¶æŠŠæ–‡ä»¶å¼•ç”¨è®¡æ•°+1
- `get_file()`ï¼šä¼ å…¥æ˜¯ `struct file`ï¼Œè¿”å› `struct file`ï¼Œè¯¥å‡½æ•°å•çº¯çš„æŠŠæ–‡ä»¶å¼•ç”¨è®¡æ•°+1
- `fput()`ï¼šå‡å°‘ä¸€æ¬¡æ–‡ä»¶å¼•ç”¨è®¡æ•°ï¼Œå¦‚æœå‡å°‘åˆ°0åˆ™ä¼šé‡Šæ”¾æ–‡ä»¶çš„ `struct file` ç»“æ„

### 1-2. `SCM_RIGHTS` æ¶ˆæ¯

**`SCM_RIGHTS`æ§åˆ¶æ¶ˆæ¯**ï¼šLinux å¼€å‘è€…å¯ä»¥ä½¿ç”¨ sendmsg ç³»ç»Ÿè°ƒç”¨å‘é€ `SCM_RIGHTS` æ•°æ®ï¼ˆå‚è§https://man7.org/linux/man-pages/man7/unix.7.htmlï¼‰**å°†æ–‡ä»¶æè¿°ç¬¦ fd ä»ä¸€ä¸ªè¿›ç¨‹å…±äº«åˆ°å¦ä¸€ä¸ªè¿›ç¨‹ï¼ˆè¯¥åŠŸèƒ½çš„æœ¬æ„æ˜¯æœ‰æƒé™æ‰“å¼€æ–‡ä»¶çš„è¿›ç¨‹æ‰“å¼€æ–‡ä»¶ç„¶åä¼ é€’ç»™æ²¡æƒé™æ‰“å¼€çš„è¿›ç¨‹ä½¿ç”¨ï¼Œå’Œ`dup2()`ä¸åŒçš„æ˜¯ï¼Œä¼ é€’åˆ°å¯¹ç«¯çš„æ–‡ä»¶æè¿°ç¬¦æ•°å­—å’Œæœ¬ç«¯ä¸ä¸€æ ·ï¼‰**ã€‚å½“senderè¿›ç¨‹å°†æ–‡ä»¶æè¿°ç¬¦ä¼ é€’ç»™å¦ä¸€ä¸ªè¿›ç¨‹receiveræ—¶ï¼Œ`SCM_RIGHTS` å°†åˆ›å»ºä¸€ä¸ªå¯¹ `file` ç»“æ„çš„å¼•ç”¨ï¼ˆè¯¥ `file` ç»“æ„æŒ‡é’ˆæ”¾åœ¨receiverç«¯çš„ `sock->sk_receive_queue` é˜Ÿåˆ—ä¸Šï¼‰ï¼Œè¿™æ ·å³ä½¿receiverè¿›ç¨‹å°šæœªæ¥æ”¶åˆ°æ–‡ä»¶æè¿°ç¬¦ï¼Œsenderä¹Ÿå¯ä»¥ç«‹å³å…³é—­è¯¥æ–‡ä»¶æè¿°ç¬¦ã€‚å½“æ–‡ä»¶æè¿°ç¬¦å¤„äºâ€œqueuedâ€ æ’é˜ŸçŠ¶æ€ï¼ˆè¡¨ç¤ºsenderå·²å‘é€å¹¶å…³é—­äº†è¯¥ fdï¼Œä½†receiverå°šæœªæ¥æ”¶ fd å¹¶å–å¾—æ‰€æœ‰æƒï¼‰æ—¶ï¼Œéœ€è¦è¿›è¡Œä¸“é—¨çš„åƒåœ¾å›æ”¶ã€‚ä¸ºäº†è·Ÿè¸ªè¿™ç§â€œqueuedâ€çŠ¶æ€ï¼Œæ–‡ç«  [io_uring, SCM_RIGHTS, and reference-count cycles](https://lwn.net/Articles/779472/) å¾ˆå¥½åœ°è§£é‡Šäº†`SCM_RIGHTS` å¼•ç”¨è®¡æ•°å’Œåƒåœ¾å›æ”¶åŸç†ã€‚

**å†…å­˜æ³„éœ²é—®é¢˜**ï¼šå¦‚æœä¸¤ä¸ªæ–‡ä»¶æè¿°ç¬¦ FD1 å’Œ FD2 éƒ½æŠŠè‡ªå·±å‘é€ç»™å¯¹æ–¹ï¼Œåœ¨éƒ½æ²¡æœ‰æ¥æ”¶åˆ°æ–‡ä»¶æè¿°ç¬¦çš„æƒ…å†µä¸‹å…³é—­ FD1 å’Œ FD2ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ª `file` ç»“æ„éƒ¨å°†æ°¸è¿œæ— æ³•é‡Šæ”¾ï¼Œé€ æˆå†…å­˜æ³„éœ²ã€‚æ‰€ä»¥è¦å¼•å…¥Linuxåƒåœ¾å›æ”¶æœºåˆ¶ï¼Œ**é‡‡ç”¨ `inflight` é£è¡Œè®¡æ•°æ¥ç»Ÿè®¡æ­£åœ¨è¢«å‘é€çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œè¯†åˆ«å†…æ ¸ä¸­çš„ä¸å¯ç ´å¾ªç¯ï¼Œå¹¶é‡Šæ”¾ä¸å¯ç ´å¾ªç¯ä¸­çš„ `file` å¯¹è±¡**ã€‚

### 1-3. å‘é€æ–‡ä»¶æè¿°ç¬¦

**`scm_cookie->fp`å­˜å‚¨ä¼ é€’ä¸­çš„ `file` ç»“æ„**ï¼šå‰é¢æåˆ°ï¼Œunix socket ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨ sendmsg å°†æ–‡ä»¶æè¿°ç¬¦å‘é€åˆ°å¦ä¸€ä¸ªsocketã€‚æˆ‘ä»¬å°†ä»senderçš„è§’åº¦å‡ºå‘ï¼Œæ¥è§£é‡Š `SCM_RIGHTS` æœŸé—´å‘ç”Ÿçš„å¼•ç”¨è®¡æ•°ã€‚é¦–å…ˆæ˜¯å‡½æ•° [unix_stream_sendmsg()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1873)ï¼Œå®ç°äº†sendmsg è°ƒç”¨çš„ä¸»è¦åŠŸèƒ½ã€‚ä¸ºäº†å®ç° `SCM_RIGHTS` åŠŸèƒ½ï¼Œå†…æ ¸ä½¿ç”¨ [scm_fp_list](https://elixir.bootlin.com/linux/v4.14.277/source/include/net/scm.h#L23) ç»“æ„æ¥ç®¡ç†æ‰€æœ‰ä¼ è¾“çš„ `file` ç»“æ„ï¼ˆä¹Ÿå³è¦ä¼ é€’çš„ `file` ç»“æ„æŒ‡é’ˆåˆ—è¡¨ï¼‰ã€‚

```c
struct scm_fp_list {
	short			count;
	short			max;
	struct user_struct	*user;
	struct file		*fp[SCM_MAX_FD];		// <--- å­˜å‚¨ä¼ é€’çš„ file
};
```

[unix_stream_sendmsg()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1886) å…ˆè°ƒç”¨ [scm_send()](https://elixir.bootlin.com/linux/v4.14.277/source/include/net/scm.h#L77) æ¥åˆå§‹åŒ– [scm_fp_list](https://elixir.bootlin.com/linux/v4.14.277/source/include/net/scm.h#L23) ç»“æ„ï¼Œå¹¶ç”±æ ˆä¸Šçš„ [scm_cookie](https://elixir.bootlin.com/linux/v4.14.277/source/include/net/scm.h#L30) ç»“æ„é‡‡ç”¨åŒé“¾è¡¨æ¥ä¿å­˜ã€‚ `scm_cookie->fp (scm_fp_list)`

```c
struct scm_cookie {
	struct pid		*pid;		/* Skb credentials */
	struct scm_fp_list	*fp;		/* Passed files		*/		// <--- ä¼ é€’ä¸­çš„ file
	struct scm_creds	creds;		/* Skb credentials	*/
#ifdef CONFIG_SECURITY_NETWORK
	u32			secid;		/* Passed security ID 	*/
#endif
};
```

**åˆå§‹åŒ–`sk_buff->fp`**ï¼šå…·ä½“è°ƒç”¨é“¾æ˜¯ [scm_send()](https://elixir.bootlin.com/linux/v4.14.277/source/include/net/scm.h#L88) -> [__scm_send()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L161) -> [scm_fp_copy()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L68)ï¼Œ**ä»ç”¨æˆ·ç©ºé—´è¯»å–æ–‡ä»¶æè¿°ç¬¦å¹¶åˆå§‹åŒ– `scm_cookie->fp`** ï¼ˆå…¶ä¸­å¯ä»¥åŒ…å«æœ€å¤š SCM_MAX_FD ä¸ª `file` ç»“æ„ï¼‰ã€‚æ³¨æ„ï¼Œ[scm_fp_copy()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L68) åˆå§‹åŒ– `scm_cookie->fp` æ—¶ä¼šå¢åŠ æ–‡ä»¶å¼•ç”¨è®¡æ•°ï¼ˆè°ƒç”¨ `fget_raw()`ï¼Œåªè¡¨ç¤ºscmæ­£åœ¨å¤„ç†è¿™ä¸ªæ–‡ä»¶ï¼‰ï¼Œæ‰€ä»¥åœ¨[unix_stream_sendmsg()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1886) ç»“å°¾ä¼šè°ƒç”¨ `scm_destroy(&scm)` å°†åˆšåˆšåˆå§‹åŒ–scmæ—¶å¢åŠ çš„æ–‡ä»¶å¼•ç”¨è®¡æ•°å‡å°‘ï¼ˆè°ƒç”¨ `fput()`ï¼‰ã€‚

ç”±äº Linux å†…æ ¸ä½¿ç”¨ `sk_buff` ï¼ˆä¹Ÿç§°ä¸ºsocketç¼“å†²åŒºæˆ–skb ï¼‰å¯¹è±¡æ¥ç®¡ç†æ‰€æœ‰ç±»å‹çš„socketæ•°æ®æŠ¥ï¼Œå› æ­¤å†…æ ¸è¿˜éœ€è¦è°ƒç”¨ **[unix_scm_to_skb()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1593) å‡½æ•°å°† `scm_cookie->fp` æ–‡ä»¶åˆ—è¡¨ç»‘å®šåˆ°ç›¸åº”çš„skb å¯¹è±¡ï¼Œå¹¶å¢åŠ æ–‡ä»¶å¼•ç”¨è®¡æ•°ï¼ˆè°ƒç”¨ [scm_fp_dup()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L332) ï¼‰å’Œé£è¡Œè®¡æ•°ï¼ˆè°ƒç”¨ [unix_inflight()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L45)ï¼‰**ã€‚å®Œæˆç»‘å®šåŠŸèƒ½çš„è°ƒç”¨é“¾æ˜¯ [unix_stream_sendmsg()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1927) -> [unix_scm_to_skb()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1603) -> [unix_attach_fds()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L103)ã€‚

```c
int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
{
	int i;

	if (too_many_unix_fds(current))
		return -ETOOMANYREFS;

	// [1] å…ˆè°ƒç”¨ scm_fp_dup()ï¼Œå¯¹æ¯ä¸€ä¸ªæ–‡ä»¶å¢åŠ å¼•ç”¨è®¡æ•°
	UNIXCB(skb).fp = scm_fp_dup(scm->fp);
	if (!UNIXCB(skb).fp)
		return -ENOMEM;

	for (i = scm->fp->count - 1; i >= 0; i--)
		unix_inflight(scm->fp->user, scm->fp->fp[i]); 	// [2] å¯¹æ¯ä¸€ä¸ªæ–‡ä»¶è°ƒç”¨ unix_inflight() å¢åŠ é£è¡Œè®¡æ•°ï¼Œå‚è§ 1-5ï¼ˆ2ï¼‰ èŠ‚
	return 0;
}
EXPORT_SYMBOL(5unix_attach_fds);
```

**å¢åŠ æ–‡ä»¶å¼•ç”¨è®¡æ•°**ï¼š[scm_fp_dup()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L332) ä¼š**å¢åŠ æ­£åœ¨ä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦çš„å¼•ç”¨è®¡æ•° `file->f_count`ï¼ˆè¡¨ç¤º[sock->sk_receive_queue](https://elixir.bootlin.com/linux/v4.14.277/source/include/net/sock.h#L359) æ¥æ”¶é˜Ÿåˆ—å¼•ç”¨äº†è¯¥æ–‡ä»¶ï¼Œæ–‡ä»¶æ­£åœ¨å‘é€ä¸­ï¼‰**ï¼Œæ‰€ä»¥å³ä½¿senderç«¯å…³é—­äº†è¯¥æ–‡ä»¶æè¿°ç¬¦ï¼Œæ–‡ä»¶ä¾ç„¶æœ‰æ•ˆã€‚

```c
struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;

	if (!fpl)
		return NULL;

	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);		// <--- å¢åŠ æ­£åœ¨ä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦çš„å¼•ç”¨è®¡æ•°
		new_fpl->max = new_fpl->count;
		new_fpl->user = get_uid(fpl->user);
	}
	return new_fpl;
}
EXPORT_SYMBOL(scm_fp_dup);
```

**å…·ä½“æ¡ˆä¾‹**ï¼šå‡è®¾æœ‰ socket A å’Œ Bï¼ŒAå°†è‡ªèº«ä¼ é€’ç»™Bã€‚åœ¨å‘é€ `SCM_RIGHTS` æ•°æ®åŒ…åï¼Œsender æ–°åˆ†é…çš„skbå°†é™„åŠ åˆ° B çš„ [sock->sk_receive_queue](https://elixir.bootlin.com/linux/v4.14.277/source/include/net/sock.h#L359) ä¸­ ï¼Œè¯¥é˜Ÿåˆ—å­˜å‚¨æ¥æ”¶åˆ°çš„æ•°æ®æŠ¥ã€‚

[unix_stream_sendmsg()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1873) åˆ›å»ºåŒ…å« `scm_fp_list` ç»“æ„çš„ `sk_buff`ï¼Œ`scm_fp_list` ä¿å­˜ä¼ è¾“æ–‡ä»¶A çš„ fp æŒ‡é’ˆã€‚ `sk_buff` è¢«è¿½åŠ åˆ° receiver é˜Ÿåˆ—ï¼ŒA çš„å¼•ç”¨è®¡æ•°ä¸º 2ï¼ŒBçš„å¼•ç”¨è®¡æ•°ä»ä¸º1ã€‚

![1-unix_stream_sendmsg](/images/posts/CVE-2021-0920/1-unix_stream_sendmsg.png)


### 1-4. æ¥æ”¶æ–‡ä»¶æè¿°ç¬¦

æ¥æ”¶ç«¯è°ƒç”¨ [unix_stream_read_generic()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2290) ï¼ˆæš‚ä¸”ä¸è®¨è®ºMSG_PEEK æ ‡å¿—ï¼Œåªå…³æ³¨æ­£å¸¸[routine](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2445)ï¼‰ã€‚é¦–å…ˆï¼Œå†…æ ¸è°ƒç”¨ `skb_peek()` ä» `sk_receive_queue` ä¸­è·å–å½“å‰çš„skb ã€‚ç„¶åï¼Œç”±äºskbä¸­ä¿å­˜äº† `scm_fp_list` ç»“æ„ï¼Œå†…æ ¸å°†è°ƒç”¨ [unix_detach_fds()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L125) è§£ææ¥è‡ªskbçš„ä¼ è¾“ `file` ç»“æ„ï¼Œå¹¶ä» `sk_receive_queue` ä¸­æ¸…é™¤skbï¼š

```c
static int unix_stream_read_generic(struct unix_stream_read_state *state,
				    bool freezable)
{
	struct scm_cookie scm;
	struct socket *sock = state->socket;
	struct sock *sk = sock->sk;
	struct unix_sock *u = unix_sk(sk);
    ...
    do {
        ...
        last = skb = skb_peek(&sk->sk_receive_queue);	// è·å–å½“å‰skb
        ...
        if (!(flags & MSG_PEEK)) {
			UNIXCB(skb).consumed += chunk;

			sk_peek_offset_bwd(sk, chunk);

			if (UNIXCB(skb).fp)
				unix_detach_fds(&scm, skb);			// <--- è§£ææ¥è‡ªskb çš„ä¼ è¾“ `file` ç»“æ„

			if (unix_skb_len(skb))
				break;

			skb_unlink(skb, &sk->sk_receive_queue);
			consume_skb(skb);

			if (scm.fp)
				break;
		}
        ...
    }
    if (state->msg)
		scm_recv(sock, state->msg, &scm, flags);	// <--- æ¥æ”¶ï¼šéå†æ–‡ä»¶æè¿°ç¬¦åˆ—è¡¨`scm->fp`å¹¶å®‰è£…æ–°çš„æ–‡ä»¶æè¿°ç¬¦
	else
		scm_destroy(&scm);
out:
	return copied ? : err;
}

void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
{
	int i;

	scm->fp = UNIXCB(skb).fp;	// è§£ææ¥è‡ªskb çš„ä¼ è¾“ `file` ç»“æ„
	UNIXCB(skb).fp = NULL;

	for (i = scm->fp->count-1; i >= 0; i--)
		unix_notinflight(scm->fp->user, scm->fp->fp[i]);
}
EXPORT_SYMBOL(unix_detach_fds);
```

[scm_recv()](https://elixir.bootlin.com/linux/v4.14.277/source/include/net/scm.h#L139) -> [scm_detach_fds()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L255) éå†ä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦åˆ—è¡¨ `scm->fp` å¹¶ä¸ºç›¸åº”åœ° receiver å®‰è£…æ–°çš„æ–‡ä»¶æè¿°ç¬¦ï¼š 

```c
void scm_detach_fds(struct msghdr *msg, struct scm_cookie *scm)
{
    ...
    for (i=0, cmfptr=(__force int __user *)CMSG_DATA(cm); i<fdmax;
	     i++, cmfptr++)
	{
		struct socket *sock;
		int new_fd;
		err = security_file_receive(fp[i]);
		if (err)
			break;
		err = get_unused_fd_flags(MSG_CMSG_CLOEXEC & msg->msg_flags
					  ? O_CLOEXEC : 0);
		if (err < 0)
			break;
		new_fd = err;
		err = put_user(new_fd, cmfptr);
		if (err) {
			put_unused_fd(new_fd);
			break;
		}
		/* Bump the usage count and install the file. */
		sock = sock_from_file(fp[i], &err);
		if (sock) {
			sock_update_netprioidx(&sock->sk->sk_cgrp_data);
			sock_update_classid(&sock->sk->sk_cgrp_data);
		}
		fd_install(new_fd, get_file(fp[i]));	// <--- å®‰è£…æ–°çš„æ–‡ä»¶æè¿°ç¬¦
	}
    ...
    __scm_destroy(scm); // æ‰€æœ‰æ–‡ä»¶çš„ä½¿ç”¨è®¡æ•°éƒ½å¢åŠ äº†ï¼Œå‡å°‘æ–‡ä»¶å¼•ç”¨è®¡æ•°å¹¶é‡Šæ”¾list
}
```

å®‰è£…æ–‡ä»¶æè¿°ç¬¦åï¼Œ[__scm_destroy()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L119) æ¸…é™¤åˆ†é…çš„ `scm->fp` å¹¶å‡å°‘æ¯ä¸ªä¼ è¾“ `file` ç»“æ„çš„æ–‡ä»¶å¼•ç”¨è®¡æ•°ï¼š

```c
void __scm_destroy(struct scm_cookie *scm)
{
	struct scm_fp_list *fpl = scm->fp;
	int i;

	if (fpl) {
		scm->fp = NULL;
		for (i=fpl->count-1; i>=0; i--)
			fput(fpl->fp[i]);		// receiver æ¥æ”¶æ–‡ä»¶åï¼Œå°±å‡å°‘å…¶å¼•ç”¨è®¡æ•°
		free_uid(fpl->user);
		kfree(fpl);
	}
}
EXPORT_SYMBOL(__scm_destroy);
```

### 1-5. å¼•ç”¨è®¡æ•°å’Œé£è¡Œè®¡æ•°

#### ï¼ˆ1ï¼‰å†…å­˜æ³„éœ²é—®é¢˜ä¸é£è¡Œè®¡æ•°

å‰é¢æåˆ°ï¼Œå½“ä½¿ç”¨ `SCM_RIGHTS` ä¼ é€’æ–‡ä»¶æè¿°ç¬¦æ—¶ï¼Œå…¶å¼•ç”¨è®¡æ•°ä¼šç«‹å³é€’å¢ã€‚ä¸€æ—¦receiver socket æ¥æ”¶å¹¶å®‰è£…äº†ä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œå¼•ç”¨è®¡æ•°å°±ä¼šå‡å°‘ã€‚

é‚£ä¹ˆå¦‚æœåœ¨senderå‘é€æ–‡ä»¶æè¿°ç¬¦ä¹‹åï¼Œåœ¨receiver æ¥æ”¶æ–‡ä»¶æè¿°ç¬¦ä¹‹å‰å…³é—­æ–‡ä»¶æè¿°ç¬¦ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ

å‡è®¾å¦‚ä¸‹åœºæ™¯ï¼š

- ï¼ˆ1ï¼‰è¯¥è¿›ç¨‹åˆ›å»ºsocket A å’Œ B ã€‚
- ï¼ˆ2ï¼‰A å°†socket A å‘é€åˆ° socket B ã€‚
- ï¼ˆ3ï¼‰B å°†socket B å‘é€ åˆ°socket A ã€‚
- ï¼ˆ4ï¼‰å…³é—­ A ã€‚
- ï¼ˆ5ï¼‰å…³é—­ Bã€‚

![å¼•ç”¨è®¡æ•°å‘¨æœŸ](/images/posts/CVE-2021-0920/2-reference_count_cycle.png)

åœ¨æ¥æ”¶ä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦ä¹‹å‰ï¼Œå…³é—­ä¸¤ä¸ªsocketã€‚A å’Œ B çš„å¼•ç”¨è®¡æ•°å‡ä¸º 1ï¼Œå¹¶ä¸”æ— æ³•è¿›ä¸€æ­¥å‡å°‘ï¼Œå› ä¸ºå½“å„è‡ªçš„è¿›ç¨‹å…³é—­å®ƒä»¬æ—¶ï¼Œå®ƒä»¬å·²ä»å†…æ ¸ fd è¡¨ä¸­åˆ é™¤ã€‚å› æ­¤å†…æ ¸æ— æ³•é‡Šæ”¾ä¸¤ä¸ªskbå’Œsockç»“æ„ï¼Œå½¢æˆä¸€ä¸ªä¸å¯ç ´çš„å¾ªç¯ã€‚**Linux å†…æ ¸åƒåœ¾å›æ”¶ç³»ç»Ÿå°±æ˜¯ä¸ºäº†é˜²æ­¢è¿™ç§æƒ…å†µä¸‹çš„å†…å­˜è€—å°½ï¼Œå¼•å…¥inflighté£è¡Œè®¡æ•°æ˜¯ä¸ºäº†è¯†åˆ«æ½œåœ¨çš„åƒåœ¾**ã€‚æ¯æ¬¡å‘é€ SCM_RIGHTS æ•°æ®æŠ¥è€Œ**å¢åŠ å¼•ç”¨è®¡æ•°æ—¶ï¼Œé£è¡Œè®¡æ•°ä¹Ÿå°†å¢åŠ **ã€‚

#### ï¼ˆ2ï¼‰æºç åˆ†æ-å¢åŠ é£è¡Œè®¡æ•°

è°ƒç”¨é“¾â€” [unix_stream_sendmsg()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1927) -> [unix_scm_to_skb()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1603) -> [unix_attach_fds()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L120) -> [unix_inflight()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L45)ã€‚å½“é‡‡ç”¨ `SCM_RIGHTS` æ•°æ®æŠ¥å‘é€æ–‡ä»¶æè¿°ç¬¦æ—¶ï¼ŒLinux å†…æ ¸å°†å…¶ `unix_sock` æ”¾å…¥å…¨å±€åˆ—è¡¨ `gc_inflight_list` ä¸­ï¼Œå¹¶é€’å¢ `unix_tot_inflight`ï¼ˆè¡¨ç¤ºé£è¡Œä¸­çš„socketæ€»æ•°ï¼‰ã€‚ç„¶åï¼Œå†…æ ¸é€’å¢ `u->unix_inflight` ä»¥è®°å½•æ¯ä¸ªæ–‡ä»¶æè¿°ç¬¦çš„é£è¡Œè®¡æ•°ï¼ˆè¡¨ç¤ºæ­£åœ¨è¢«ä¼ é€’çš„æ•°ç›®ï¼‰ï¼š 

```c
void unix_inflight(struct user_struct *user, struct file *fp)
{
	struct sock *s = unix_get_socket(fp);	// [1] åªæœ‰socket å’Œio_uringçš„fdæ‰èƒ½æ‰¾åˆ°sock

	spin_lock(&unix_gc_lock);

	if (s) { // [2] å¯¹äºsockç±»å‹æ–‡ä»¶åˆ™å¢åŠ é£è¡Œè®¡æ•°
		struct unix_sock *u = unix_sk(s);

		if (atomic_long_inc_return(&u->inflight) == 1) {
			BUG_ON(!list_empty(&u->link));
			list_add_tail(&u->link, &gc_inflight_list);		// [2] å°† unix_sock æ”¾å…¥å…¨å±€åˆ—è¡¨ gc_inflight_list
		} else {
			BUG_ON(list_empty(&u->link));
		}
		/* Paired with READ_ONCE() in wait_for_unix_gc() */
		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);	// [2] é€’å¢unix_tot_inflight ï¼ˆè¡¨ç¤ºé£è¡Œä¸­çš„socketæ€»æ•°ï¼‰
	}
	user->unix_inflight++;	// ç”¨æˆ·ç»Ÿè®¡é£è¡Œè®¡æ•°å¢åŠ 
	spin_unlock(&unix_gc_lock);
}
```

#### ï¼ˆ3ï¼‰ä¸å¯ç ´å¾ªç¯ç¤ºä¾‹

å½“æ–‡ä»¶æè¿°ç¬¦Aå°†è‡ªå·±å‘é€ç»™æ–‡ä»¶æè¿°ç¬¦Bæ—¶ï¼Œä»¥ä¸‹æ˜¯ `sk_buff` çš„çŠ¶æ€ï¼ˆæ–‡ä»¶æè¿°ç¬¦Açš„å¼•ç”¨è®¡æ•°å’Œé£è¡Œè®¡æ•°éƒ½å¢åŠ äº†ï¼‰ï¼Œæ–‡ä»¶æè¿°ç¬¦Açš„å¼•ç”¨è®¡æ•°ä¸º2ï¼Œé£è¡Œè®¡æ•°ä¸º1ã€‚å¯¹äºæ¥æ”¶æ–¹æ–‡ä»¶æè¿°ç¬¦Bï¼Œæ–‡ä»¶å¼•ç”¨è®¡æ•°ä¸º1ï¼Œé£è¡Œè®¡æ•°ä¸º0ã€‚

![3-inflight_count_A](/images/posts/CVE-2021-0920/3-inflight_count_A.png)

å½“ä»å¦ä¸€ç«¯æ¥æ”¶åˆ°socketæ–‡ä»¶æè¿°ç¬¦æ—¶ï¼Œ`unix_sock->inflight` è®¡æ•°å°†å‡å°‘ã€‚

å†æ¬¡å›é¡¾å…³é—­ç³»ç»Ÿè°ƒç”¨ä¹‹å‰çš„å¼•ç”¨è®¡æ•°å¾ªç¯åœºæ™¯ã€‚è¿™ä¸ªå¾ªç¯æ˜¯å¯æ‰“ç ´çš„ï¼Œå› ä¸ºä»»ä½•socketæ–‡ä»¶éƒ½å¯ä»¥æ¥æ”¶ä¼ è¾“çš„æ–‡ä»¶å¹¶æ‰“ç ´å¼•ç”¨å¾ªç¯ï¼Œå…³é—­Aå’ŒBä¹‹å‰çš„å¯ç ´å¾ªç¯å¦‚ä¸‹æ‰€ç¤ºï¼š 

æ–‡ä»¶æè¿°ç¬¦ A å°†è‡ªèº«å‘é€åˆ°æ–‡ä»¶æè¿°ç¬¦ Bï¼Œåä¹‹äº¦ç„¶ã€‚ æ–‡ä»¶æè¿°ç¬¦Aå’ŒBçš„é£è¡Œè®¡æ•°éƒ½æ˜¯1ï¼Œæ–‡ä»¶å¼•ç”¨è®¡æ•°éƒ½æ˜¯2ã€‚

![4-breakable_cycle_before_close_A](/images/posts/CVE-2021-0920/4-breakable_cycle_before_close_A.png)

å…³é—­ä¸¤ä¸ªæ–‡ä»¶æè¿°ç¬¦åï¼Œ**å¾ªç¯å˜å¾—ç‰¢ä¸å¯ç ´ï¼ˆæ— æ³•é€šè¿‡æ¥æ”¶æ–‡ä»¶æè¿°ç¬¦æ¥æ‰“ç ´å¾ªç¯ï¼Œå‡å°‘å¼•ç”¨è®¡æ•°ï¼‰**ï¼ŒAå’ŒBçš„å¼•ç”¨è®¡æ•°éƒ½ç­‰äºæ¯ä¸ªsocketæ–‡ä»¶æè¿°ç¬¦çš„é£è¡Œè®¡æ•°ï¼Œè¿™æ˜¯å¯èƒ½å­˜åœ¨åƒåœ¾çš„è¿¹è±¡ï¼š

![5-unbreakable_cycle_after_close_A](/images/posts/CVE-2021-0920/5-unbreakable_cycle_after_close_A.png)

#### ï¼ˆ4ï¼‰å¯ç ´å¾ªç¯ç¤ºä¾‹

åœºæ™¯2ã€‚å‡è®¾æˆ‘ä»¬æœ‰socket Aã€B å’Œğ›¼ ï¼š

1. A å°†socket A å‘é€åˆ°socket Bã€‚
2. B å°†socket B å‘é€åˆ°socket A ã€‚
3. B å°†socket B å‘é€åˆ°socket ğ›¼ ã€‚
4. ğ›¼ å°†socket ğ›¼ å‘é€åˆ°socket Bã€‚
5. å…³é—­ Aã€‚
6. å…³é—­ Bã€‚

A / B / ğ›¼ å½¢æˆä¸€ä¸ªå¯ç ´çš„å¾ªç¯ã€‚è¿™ä¸ªå¾ªç¯æ˜¯å¯æ‰“ç ´çš„ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥ä»socketæ–‡ä»¶æè¿°ç¬¦ ğ›¼ å¾—åˆ°æ–°å®‰è£…çš„æ–‡ä»¶æè¿°ç¬¦ B' ï¼Œ ä» B' å¾—åˆ°æ–°å®‰è£…çš„æ–‡ä»¶æè¿°ç¬¦ A'ï¼ˆ**å¯ä»¥é€šè¿‡æ¥æ”¶æ–‡ä»¶æè¿°ç¬¦æ¥æ‰“ç ´å¾ªç¯ï¼Œå‡å°‘å¼•ç”¨è®¡æ•°**ï¼‰ã€‚

![6-breakable_cycle_for_A_B](/images/posts/CVE-2021-0920/6-breakable_cycle_for_A_B.png)

### 1-6. åƒåœ¾å›æ”¶

åƒåœ¾å›æ”¶æœºåˆ¶å¯å‚è§ [io_uring, SCM_RIGHTS, and reference-count cycles](https://lwn.net/Articles/779472/)ã€‚

#### ï¼ˆ1ï¼‰è¯†åˆ«ä¸å¯ç ´å¼•ç”¨å¾ªç¯

**æœç´¢ä¸å¯ç ´å¾ªç¯çš„æµç¨‹**ï¼šå¦‚æœå¼•ç”¨è®¡æ•°å’Œé£è¡Œè®¡æ•°ç›¸ç­‰ï¼Œåˆ™è¯¥ `file` ç»“æ„å¯èƒ½å±äºä¸å¯ç ´å¾ªç¯ã€‚é¦–å…ˆï¼Œå†…æ ¸æ‰¾åˆ°æ‰€æœ‰é£è¡Œä¸­çš„socketï¼ˆ`SCM_RIGHTS`æ•°æ®æŠ¥ä¸­åŒ…å«å…¶å¼•ç”¨çš„socketï¼‰ï¼Œä¹Ÿå³`f_count` å’Œ `inflight` å€¼ç›¸ç­‰çš„socketã€‚ç„¶åï¼Œè®¡ç®—å¯¹æ¯ä¸ªsocketçš„å¼•ç”¨æœ‰å¤šå°‘æ¥è‡ªé™„åŠ åˆ°è¯¥é›†åˆä¸­socketçš„ SCM_RIGHTS æ•°æ®æŠ¥ï¼Œå¦‚æœæŸsocketå…·æœ‰æ¥è‡ªé›†åˆå¤–éƒ¨çš„å¼•ç”¨ï¼Œåˆ™è¡¨æ˜å…¶å¯è¾¾å¹¶ä¸”å¯ä»¥æ’é™¤äº†ã€‚å¦‚æœæŸsocketä»å¤–éƒ¨å¯ä»¥è®¿é—®åˆ°ï¼Œå¹¶ä¸”æœ‰æŸä¸ª `SCM_RIGHTS` æ•°æ®æŠ¥é™„åŠ åˆ°è¯¥socketï¼Œåˆ™è¯¥æ•°æ®æŠ¥ä¸­åŒ…å«çš„æ–‡ä»¶ä¹Ÿæ˜¯å¯è®¿é—®çš„ï¼Œå¯ä»¥æ’é™¤ã€‚

ç»è¿‡è¿­ä»£æœç´¢å’Œæ’é™¤ä¹‹åï¼Œå†…æ ¸æœ€ç»ˆä¼šæ‰¾åˆ°ä¸€ç»„é£è¡Œä¸­çš„socketï¼Œè¿™äº›socketä»…è¢«é›†åˆå†…socketçš„ `SCM_RIGHTS` æ•°æ®æŠ¥æ‰€å¼•ç”¨ã€‚è¯¥ `file` ç»“æ„å¾ªç¯ä¸­ï¼Œå„è‡ªåŒ…å«å¯¹å½¼æ­¤çš„å”¯ä¸€å¼•ç”¨ã€‚åªè¦ä»`sock->sk_receive_queue`æ¥æ”¶é˜Ÿåˆ—ä¸­åˆ é™¤è¿™äº›æ•°æ®æŠ¥ï¼Œé‡Šæ”¾å®ƒä»¬æŒæœ‰çš„å¼•ç”¨ï¼Œå°±èƒ½æ‰“ç ´å¾ªç¯ï¼Œé‡Šæ”¾è¿™äº›socketã€‚

**ä»£ç æµç¨‹**ï¼š`SCM_RIGHTS` åƒåœ¾å›æ”¶ç³»ç»Ÿä¸­ï¼Œ[unix_gc()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L210) å‡½æ•°è´Ÿè´£è¯†åˆ«ä¸å¯ç ´çš„å¼•ç”¨å¾ªç¯ï¼Œè¿‡ç¨‹å¦‚ä¸‹ã€‚

- [1] é¦–å…ˆï¼Œå°†ä»»ä½•å¼•ç”¨è®¡æ•°ç­‰äºå…¶é£è¡Œè®¡æ•°çš„ `unix_sock` å¯¹è±¡æ·»åŠ åˆ° `gc_candidates` åˆ—è¡¨ä¸­ï¼ˆä½œä¸ºåƒåœ¾å›æ”¶çš„å€™é€‰ï¼‰ã€‚
- [2] ç„¶åï¼Œç¡®å®š socket æ˜¯å¦è¢« `gc_candidates` åˆ—è¡¨ä¹‹å¤–çš„ä»»ä½• socket æ‰€å¼•ç”¨ã€‚å¦‚æœæ˜¯ï¼Œé‚£ä¹ˆå®ƒæ˜¯å¯è¾¾çš„ï¼Œå°±ä» `gc_candidates` åˆ—è¡¨ä¸­åˆ é™¤å®ƒå’Œå®ƒå¼•ç”¨çš„ä»»ä½•socketã€‚é‡å¤è¯¥è¿‡ç¨‹ï¼Œç›´åˆ°æ‰¾ä¸åˆ°å¯åˆ°è¾¾çš„socketã€‚ï¼ˆå®é™…æ˜¯è°ƒç”¨ [scan_children()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L138) å’Œå‡½æ•°æŒ‡é’ˆ [dec_inflight](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L172) æ¥éå†æ¯ä¸ªå€™é€‰socketçš„ `sk->receive_queue`æ¥æ”¶é˜Ÿåˆ—ï¼Œ**å‡å°‘æ¯ä¸ªä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦ï¼ˆä½äº`gc_candidates` åˆ—è¡¨å†…çš„æ–‡ä»¶æè¿°ç¬¦ï¼‰çš„é£è¡Œè®¡æ•°**ï¼›è¿­ä»£ç»“æŸåï¼Œ**å¦‚æœè¿˜æœ‰å€™é€‰socketçš„é£è¡Œè®¡æ•°å¤§äº0ï¼Œåˆ™è¯´æ˜å…¶å­˜åœ¨å¤–éƒ¨å¼•ç”¨**ï¼Œéœ€ä»`gc_candidates`åˆ—è¡¨æ’é™¤ï¼›éœ€è°ƒç”¨ [scan_children()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L166) -> [scan_inflight()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L96) éå†gc_candidatesåˆ—è¡¨ä¸­æ¯ä¸ªä¼ è¾“æ–‡ä»¶çš„æ¥æ”¶é˜Ÿåˆ— `sock->sk_receive_queue`ï¼Œå¹¶**é€’å¢æ¢å¤é£è¡Œè®¡æ•°**ï¼‰
- [3] è¿­ä»£ç»“æŸåï¼Œ`gc_candidates` åˆ—è¡¨ä¸­çš„socketåªè¢«`gc_candidates` åˆ—è¡¨å†…çš„socketæ‰€å¼•ç”¨ã€‚

```c
void unix_gc(void)
{
	struct unix_sock *u;
	struct unix_sock *next;
	struct sk_buff_head hitlist;
	struct list_head cursor;
	LIST_HEAD(not_cycle_list);
	...

	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {	// [1]
		long total_refs;
		long inflight_refs;

		total_refs = file_count(u->sk.sk_socket->file);
		inflight_refs = atomic_long_read(&u->inflight);

		BUG_ON(inflight_refs < 1);
		BUG_ON(total_refs < inflight_refs);
		if (total_refs == inflight_refs) {		// è‹¥å¼•ç”¨è®¡æ•°ç­‰äºé£è¡Œè®¡æ•°ï¼Œåˆ™æ”¾å…¥`gc_candidates`åˆ—è¡¨
			list_move_tail(&u->link, &gc_candidates);
			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);	// è®¾ç½®ä¸¤ä¸ªflagï¼ˆUNIX_GC_CANDIDATE/UNIX_GC_MAYBE_CYCLEï¼‰
			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
		}
	}

	list_for_each_entry(u, &gc_candidates, link)					// [2] éå†æ¯ä¸ªå€™é€‰socketçš„ `sk->receive_queue`æ¥æ”¶é˜Ÿåˆ—ï¼Œå‡å°‘æ¯ä¸ªä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦ï¼ˆä½äº`gc_candidates` åˆ—è¡¨å†…çš„æ–‡ä»¶æè¿°ç¬¦ï¼‰çš„é£è¡Œè®¡æ•°
		scan_children(&u->sk, dec_inflight, NULL);

	list_add(&cursor, &gc_candidates);
	while (cursor.next != &gc_candidates) {
		u = list_entry(cursor.next, struct unix_sock, link);

		/* Move cursor to after the current position. */
		list_move(&cursor, &u->link);

		if (atomic_long_read(&u->inflight) > 0) {					// [3] è¿­ä»£ç»“æŸåï¼Œ`gc_candidates`å‰©ä¸‹çš„ socket å¦‚æœé£è¡Œè®¡æ•°ä»å¤§äº0ï¼Œåˆ™è¯´æ˜å­˜åœ¨å¤–éƒ¨å¼•ç”¨ï¼Œæ˜¯å¯è¾¾çš„ï¼Œéœ€ä»`gc_candidates`åˆ—è¡¨ç§»é™¤ï¼Œå¹¶æ¢å¤ç›¸å…³çš„é£è¡Œè®¡æ•°
			list_move_tail(&u->link, &not_cycle_list);	// å°†å€™é€‰è€…æ”¾å…¥ `not_cycle_list`ï¼Œå¹¶éå†gc_candidatesåˆ—è¡¨ä¸­æ¯ä¸ªä¼ è¾“æ–‡ä»¶gc_inflight_listçš„æ¥æ”¶é˜Ÿåˆ—sock->sk_receive_queueï¼Œå¹¶é€’å¢æ¢å¤å…¶é£è¡Œè®¡æ•°
			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
			scan_children(&u->sk, inc_inflight_move_tail, NULL);	// é€’å¢æ¢å¤é£è¡Œè®¡æ•°
		}
	}
	list_del(&cursor);

	skb_queue_head_init(&hitlist);				// ç°åœ¨`gc_candidates`åˆ—è¡¨ä¸­åªåŒ…å«åƒåœ¾socketï¼Œæ¢å¤å…¶é£è¡Œè®¡æ•°
	list_for_each_entry(u, &gc_candidates, link)
		scan_children(&u->sk, inc_inflight, &hitlist);

	/* not_cycle_list contains those sockets which do not make up a
	 * cycle.  Restore these to the inflight list.
	 */
	while (!list_empty(&not_cycle_list)) {		// å°†å€™é€‰è€…ä» not_cycle_list ç§»å›åˆ° gc_inflight_list 
		u = list_entry(not_cycle_list.next, struct unix_sock, link);
		__clear_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
		list_move_tail(&u->link, &gc_inflight_list);
	}

	spin_unlock(&unix_gc_lock);

	__skb_queue_purge(&hitlist);				// [4] è°ƒç”¨ __skb_queue_purge() æ¸…é™¤åƒåœ¾

	spin_lock(&unix_gc_lock);
	...
}
```

[__skb_queue_purge()](https://elixir.bootlin.com/linux/v4.14.277/source/include/linux/skbuff.h#L2646) å‡½æ•°è´Ÿè´£æ¸…é™¤åƒåœ¾ï¼Œé‡Šæ”¾åƒåœ¾é˜Ÿåˆ—ä¸­æ¯ä¸€ä¸ªskbï¼Œå¹¶æŠŠ `skb->cb.fp` ä¸­çš„æ–‡ä»¶è°ƒç”¨`scm_destroy()` é‡Šæ”¾ ï¼š

```c
void skb_queue_purge(struct sk_buff_head *list);
static inline void __skb_queue_purge(struct sk_buff_head *list) // åˆ é™¤ &sk_buff åˆ—è¡¨ä¸­çš„æ‰€æœ‰ç¼“å†²åŒºï¼Œå¹¶åˆ é™¤å…¶å¼•ç”¨ã€‚æœ¬å‡½æ•°ä¸ä½¿ç”¨åˆ—è¡¨é”ï¼Œæ‰€ä»¥è°ƒç”¨è€…å¿…é¡»è·å¾—ç›¸å…³çš„é”æ‰èƒ½ä½¿ç”¨å®ƒã€‚
{
	struct sk_buff *skb;
	while ((skb = __skb_dequeue(list)) != NULL)
		kfree_skb(skb);
}
```

æœ‰ä¸¤ç§æ–¹å¼å¯ä»¥è§¦å‘åƒåœ¾å›æ”¶ï¼š

1.  å¦‚æœæœ‰è¶…è¿‡ 16,000 ä¸ªé£è¡Œsocketï¼Œåˆ™åœ¨ `sendmsg()` å‡½æ•°å¼€å¤´è°ƒç”¨ [wait_for_unix_gc()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L196)
2. å½“å…³é—­ä¸€ä¸ªsocketæ–‡ä»¶æè¿°ç¬¦æ—¶ï¼Œå†…æ ¸å°†ç›´æ¥è°ƒç”¨ [unix_gc()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L210)ã€‚

æ³¨æ„ï¼Œ [unix_gc()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L210) ä¸æ˜¯æŠ¢å å¼çš„ã€‚å¦‚æœåƒåœ¾å›æ”¶å·²ç»åœ¨è¿è¡Œï¼Œå†…æ ¸å°†ä¸ä¼šæ‰§è¡Œå¦ä¸€ä¸ª [unix_gc()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L210) è°ƒç”¨ã€‚

#### ï¼ˆ2ï¼‰æ¡ˆä¾‹åˆ†æ

ç°åœ¨ï¼Œé€šè¿‡ä¸€ä¸ªå¯ç ´å¾ªç¯æ¥æµ‹è¯•ä¸€ä¸‹ï¼Œå‡è®¾æœ‰ä¸€å¯¹ socket $f0_0$ å’Œ $f0_1$ï¼Œä»¥åŠå•ä¸ªsocket ğ›¼ï¼š

- ï¼ˆ1ï¼‰socket $f0_0$ å°† socket $f0_0$ å‘é€åˆ° socket $f0_1$
- ï¼ˆ2ï¼‰socket $f0_1$ å°† socket $f0_1$ å‘é€åˆ° socket ğ›¼
- ï¼ˆ3ï¼‰å…³é—­ $f0_0$
- ï¼ˆ4ï¼‰å…³é—­ $f0_1$

åœ¨å¼€å§‹åƒåœ¾å›æ”¶å‰ï¼Œsocketæ–‡ä»¶æè¿°ç¬¦çš„çŠ¶æ€å¦‚ä¸‹ï¼Œæ„æˆå¯ç ´å¾ªç¯ï¼š

- $f0_0$: ref = 1, inflight = 1
- $f0_1$: ref = 1, inflight = 1
- ğ›¼ : ref = 1, inflight = 0

![7_breakable_cycle_by_f0](/images/posts/CVE-2021-0920/7_breakable_cycle_by_f0.png)



åœ¨åƒåœ¾å›æ”¶æ—¶ï¼Œ$f0_0$ å’Œ $f0_1$ è¢«è§†ä¸ºåƒåœ¾å€™é€‰ã€‚$f0_0$ çš„é£è¡Œè®¡æ•°é™ä¸ºé›¶ï¼Œä½† $f0_1$ çš„é£è¡Œè®¡æ•°ä»ä¸º 1ï¼Œå› ä¸ºğ›¼ ä¸æ˜¯å€™é€‰è€…ã€‚å› æ­¤ï¼Œå†…æ ¸å°†ä» $f0_1$ çš„ æ¥æ”¶é˜Ÿåˆ—ä¸­æ¢å¤é£è¡Œè®¡æ•°ã€‚ç»“æœï¼Œ$f0_0$ å’Œ $f0_1$ ä¸å†è¢«è§†ä¸ºåƒåœ¾ã€‚ 

## 2. CVE-2021-0920 æ¼æ´åˆ†æ

å½“ç”¨æˆ·é€šè¿‡ `recvmsg`ï¼ˆä¸å« `MSG_PEEK` æ ‡å¿—ï¼‰æ¥æ”¶åˆ° `SCM_RIGHTS` æ¶ˆæ¯æ—¶ï¼Œå†…æ ¸å°†ç­‰å¾…æ­£åœ¨è¿›è¡Œçš„åƒåœ¾å›æ”¶å®Œæˆã€‚ä½†æ˜¯ï¼Œå¦‚æœæ‰“å¼€äº† `MSG_PEEK` æ ‡å¿—ï¼Œå†…æ ¸å°†å¢åŠ ä¼ è¾“æ–‡ä»¶ç»“æ„çš„å¼•ç”¨è®¡æ•°ï¼Œè€Œä¸ä¸ä»»ä½•æ­£åœ¨è¿›è¡Œçš„åƒåœ¾å›æ”¶è¿‡ç¨‹åŒæ­¥ï¼ˆ**é—®é¢˜å°±åœ¨äºæ²¡æœ‰å®æ–½åŒæ­¥æœºåˆ¶**ï¼‰ã€‚è¿™å¯èƒ½ä¼šå¯¼è‡´å†…éƒ¨åƒåœ¾å›æ”¶çŠ¶æ€çš„ä¸ä¸€è‡´ï¼Œä½¿åƒåœ¾å›æ”¶å™¨å°†éåƒåœ¾çš„ sock å¯¹è±¡é”™è¯¯è¯†åˆ«ä¸ºè¦æ¸…é™¤çš„åƒåœ¾ã€‚

### 2-1. è°ƒç”¨ recvmsgâ€”ä¸å¸¦ MSG_PEEK æ ‡å¿—ï¼ˆå¼•ç”¨è®¡æ•°ä¸å˜ï¼Œå‡å°‘é£è¡Œè®¡æ•°ï¼‰

åœ¨**æœªè®¾ç½® MSG_PEEK æ ‡å¿—**æ—¶ï¼Œ[unix_stream_read_generic()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2290) å‡½æ•°è´Ÿè´£è§£æ `SCM_RIGHTS` æ¶ˆæ¯å¹¶ç®¡ç†æ–‡ä»¶é£è¡Œè®¡æ•° ã€‚ç„¶åï¼Œ[unix_stream_read_generic()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2445) è°ƒç”¨ [unix_detach_fds()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L125) æ¥å‡å°‘é£è¡Œè®¡æ•°ï¼Œå¹¶ä»skbä¸­æ¸…é™¤ä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦åˆ—è¡¨ `scm_fp_list`ã€‚ 

```c
void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
{
	int i;

	scm->fp = UNIXCB(skb).fp;
	UNIXCB(skb).fp = NULL;			// æ¸…ç©º fp æŒ‡é’ˆ

	for (i = scm->fp->count-1; i >= 0; i--)
		unix_notinflight(scm->fp->user, scm->fp->fp[i]);	// å‡å°‘é£è¡Œè®¡æ•°ï¼Œå¹¶ä»skbä¸­æ¸…é™¤ä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦åˆ—è¡¨ `scm_fp_list`
}
EXPORT_SYMBOL(unix_detach_fds);
```

[unix_detach_fds()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L133) -> [unix_notinflight()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L67) è´Ÿè´£å‡å°‘é£è¡Œè®¡æ•°ï¼ŒåŠŸèƒ½å’Œ [unix_inflight()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L45) æ°å¥½ç›¸åã€‚

```c
void unix_notinflight(struct user_struct *user, struct file *fp)
{
	struct sock *s = unix_get_socket(fp);

	spin_lock(&unix_gc_lock);

	if (s) {
		struct unix_sock *u = unix_sk(s);

		BUG_ON(!atomic_long_read(&u->inflight));
		BUG_ON(list_empty(&u->link));

		if (atomic_long_dec_and_test(&u->inflight))		// å‡å°‘é£è¡Œè®¡æ•°
			list_del_init(&u->link);
		/* Paired with READ_ONCE() in wait_for_unix_gc() */
		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
	}
	user->unix_inflight--;
	spin_unlock(&unix_gc_lock);
}
```

ä¹‹å [unix_stream_read_generic()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2451) è°ƒç”¨ [skb_unlink()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/skbuff.c#L2955) å’Œ [consume_skb()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/skbuff.c#L708) æ¥é‡Šæ”¾å½“å‰skbã€‚è°ƒç”¨é“¾ [consume_skb()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/skbuff.c#L714) -> [\_\_kfree_skb()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/skbuff.c#L654) -> [skb_release_all()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/skbuff.c#L638) -> [skb_release_head_state()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/skbuff.c#L625) -> [skb->destructor](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1605) å®é™…ä¼šè°ƒç”¨ [unix_destruct_scm()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L137) å‡½æ•°ï¼š 

```c
void unix_destruct_scm(struct sk_buff *skb)
{
	struct scm_cookie scm;

	memset(&scm, 0, sizeof(scm));
	scm.pid  = UNIXCB(skb).pid;
	if (UNIXCB(skb).fp)
		unix_detach_fds(&scm, skb);		// !!!!!!! æ¼æ´ç‚¹ï¼Œç”±äº

	/* Alas, it calls VFS */
	/* So fscking what? fput() had been SMP-safe since the last Summer */
	scm_destroy(&scm);
	sock_wfree(skb);
}
EXPORT_SYMBOL(unix_destruct_scm);
```

**é—®é¢˜**ï¼šå®é™…ä¸Šä¸ä¼šæ‰§è¡Œ [unix_detach_fds()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L125) å‡½æ•°ï¼Œå› ä¸º `UNIXCB(skb).fp` å·²ç»è¢« [unix_detach_fds()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L125) æ¸…é™¤ã€‚æœ€åï¼Œ[unix_stream_read_generic()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2480) -> [scm_recv()](https://elixir.bootlin.com/linux/v4.14.277/source/include/net/scm.h#L139) -> [scm_detach_fds()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L255)  è°ƒç”¨`fd_install(new_fd, get_file(fp[i]))` æ¥å®‰è£…æ–°çš„æ–‡ä»¶æè¿°ç¬¦ã€‚

### 2-2. è°ƒç”¨ recvmsgâ€”å¸¦ MSG_PEEK æ ‡å¿—ï¼ˆå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œé£è¡Œè®¡æ•°ä¸å˜ï¼‰

å¦‚æœè®¾ç½®äº†MSG_PEEKæ ‡å¿—ï¼Œåˆ™ recvmsg è¿‡ç¨‹ä¸åŒã€‚åœ¨æ¥æ”¶æ—¶ç”¨MSG_PEEK æ ‡å¿—æ¥â€œæŸ¥çœ‹â€æ¶ˆæ¯ï¼Œä½†æ•°æ®è¢«è§†ä¸ºæœªè¯»ã€‚[unix_stream_read_generic()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2459) -> [unix_peek_fds()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1548) -> [scm_fp_dup()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L332) è°ƒç”¨çš„æ˜¯ [scm_fp_dup()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L332) è€Œä¸æ˜¯ [unix_detach_fds()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L125) ã€‚è¿™ä¼šå¢åŠ é£è¡Œæ–‡ä»¶çš„å¼•ç”¨è®¡æ•°ã€‚

```c
static int unix_stream_read_generic(struct unix_stream_read_state *state,
				    bool freezable)
{
	struct scm_cookie scm;
  ...
  if (!(flags & MSG_PEEK)) {
    ...
  } else {
			/* It is questionable, see note in unix_dgram_recvmsg.
			 */
			if (UNIXCB(skb).fp)
				unix_peek_fds(&scm, skb);
    ...
  }
}

static void unix_peek_fds(struct scm_cookie *scm, struct sk_buff *skb)
{
	scm->fp = scm_fp_dup(UNIXCB(skb).fp);
  ...
}

struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;

	if (!fpl)
		return NULL;

	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);						// å¢åŠ é£è¡Œæ–‡ä»¶çš„å¼•ç”¨è®¡æ•°
		new_fpl->max = new_fpl->count;
		new_fpl->user = get_uid(fpl->user);
	}
	return new_fpl;
}
EXPORT_SYMBOL(scm_fp_dup);
```

ç”±äºæ•°æ®åº”è¯¥è¢«è§†ä¸ºæœªè¯»ï¼Œæ‰€ä»¥å½“è®¾ç½®MSG_PEEKæ ‡å¿—æ—¶ï¼Œ skb ä¸ä¼šè¢«unlinkå’Œé‡Šæ”¾ã€‚ä½†æ˜¯ï¼Œreceiver ç«¯ä»å°†è·å¾—é£è¡Œsocketçš„æ–°æ–‡ä»¶æè¿°ç¬¦ã€‚

### 2-3. recvmsgç¤ºä¾‹

å…·ä½“ç¤ºä¾‹ï¼Œå‡è®¾æœ‰socketå¯¹ $f0_0$ / $f0_1$  å’Œ $f1_0$ / $f1_1$ï¼Œè¯¥ç¨‹åºæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

- $f0_0$ â†’ [$f0_0$] â†’ $f0_1$ ï¼ˆè¡¨ç¤º $f0_0$ å‘é€ [$f0_0$] åˆ° $f0_1$ï¼‰
- $f1_0$ â†’ [$f0_0$] â†’ $f1_1$
- close($f0_0$)

$f0_0$ / $f0_1$  å’Œ $f1_0$ / $f1_1$ å½¢æˆä¸€ä¸ªå¯ç ´çš„å¾ªç¯

![8-breakable_cycle_by_f0](./picture/8-breakable_cycle_by_f0.png)

çŠ¶æ€å¦‚ä¸‹ï¼š

- inflight($f0_0$) = 2, ref($f0_0$) = 2
- inflight($f0_1$) = 0, ref($f0_1$) = 1
- inflight($f1_0$) = 0, ref($f1_0$) = 1
- inflight($f1_1$) = 0, ref($f1_1$) = 1

å¦‚æœç°åœ¨å‘ç”Ÿåƒåœ¾å›æ”¶è¿‡ç¨‹ï¼Œåœ¨è°ƒç”¨recvmsgä¹‹å‰ï¼Œå†…æ ¸ä¼šå°†$f0_0$ä½œä¸ºåƒåœ¾å€™é€‰è€…ã€‚ä½†æ˜¯ï¼Œ$f0_0$ä¸ä¼šæ›´æ”¹é£è¡Œè®¡æ•°ï¼Œå†…æ ¸ä¹Ÿä¸ä¼šæ¸…é™¤ä»»ä½•åƒåœ¾ã€‚

æ¥ç€ï¼Œå¦‚æœ $f0_1$ è°ƒç”¨recvmsgï¼ˆ**å¸¦MSG_PEEKæ ‡å¿—**ï¼‰ï¼Œåˆ™**$f0_1$çš„æ¥æ”¶é˜Ÿåˆ—ä¿æŒä¸å˜ï¼ˆæœªè¢«æ¸…é™¤ï¼‰**å¹¶ä¸”é£è¡Œè®¡æ•°ä¸ä¼šå‡å°‘ã€‚$f0_1$ è·å¾—ä¸€ä¸ªæ–°çš„æ–‡ä»¶æè¿°ç¬¦ $f0_0$' ï¼Œå®ƒä¼š**å¢åŠ  $f0_0$ ä¸Šçš„æ–‡ä»¶å¼•ç”¨è®¡æ•°**ï¼š 

![9-MSG_PEEK_increment](./picture/9-MSG_PEEK_increment.png)

çŠ¶æ€å¦‚ä¸‹ï¼š

- inflight($f0_0$) = 2, ref($f0_0$) = 3
- inflight($f0_1$) = 0, ref($f0_1$) = 1
- inflight($f1_0$) = 0, ref($f1_0$) = 1
- inflight($f1_1$) = 0, ref($f1_1$) = 1

æ¥ç€ï¼Œ$f0_1$ è°ƒç”¨recvmsgï¼ˆ**ä¸å¸¦MSG_PEEKæ ‡å¿—**ï¼‰ï¼Œ**$f0_1$çš„æ¥æ”¶é˜Ÿåˆ—è¢«æ¸…ç©ºç§»é™¤ï¼Œ$f0_1$è¿˜è·å¾—ä¸€ä¸ªæ–°çš„æ–‡ä»¶æè¿°ç¬¦$f0_0$''** ï¼š 

![10-receive_queue_of_f0](./picture/10-receive_queue_of_f0.png)

çŠ¶æ€å¦‚ä¸‹ï¼š

- inflight($f0_0$) = 2, ref($f0_0$) = 3
- inflight($f0_1$) = 0, ref($f0_1$) = 1
- inflight($f1_0$) = 0, ref($f1_0$) = 1
- inflight($f1_1$) = 0, ref($f1_1$) = 1

### 2-4. skb UAFæ¼æ´

ä» high-level æ¥çœ‹ï¼Œç”±äº MSG_PEEK å’Œåƒåœ¾å›æ”¶å™¨ä¸åŒæ­¥ï¼Œå¯¼è‡´ Linux åƒåœ¾å›æ”¶çš„å†…éƒ¨çŠ¶æ€ä¸ç¡®å®šã€‚è¿™é‡Œå¯èƒ½å¯¼è‡´ç«äº‰ï¼Œåƒåœ¾å›æ”¶å™¨å¯ä»¥å°†é£è¡Œä¸­çš„socketè§†ä¸ºåƒåœ¾å€™é€‰ï¼Œè€ŒåŒæ—¶å¸¦MSG_PEEKæ ‡å¿—æ¥æ”¶æ—¶ä¼šé€’å¢æ–‡ä»¶å¼•ç”¨ã€‚å› æ­¤ï¼Œåƒåœ¾å›æ”¶å™¨å¯èƒ½ä¼šæ¸…é™¤å€™é€‰è€…ï¼Œé‡Šæ”¾socketç¼“å†²åŒºï¼Œè€Œreceiverç«¯å¯èƒ½ä¼šå®‰è£…æ–‡ä»¶æè¿°ç¬¦ï¼Œä»è€Œå¯¼è‡´ skb å¯¹è±¡çš„ UAFã€‚

æ¥ä¸‹æ¥çœ‹çœ‹æ¼æ´è§¦å‘è¿‡ç¨‹ã€‚é¦–å…ˆï¼Œåˆ†é…å¦‚ä¸‹socketå¯¹å’Œå•ä¸ªsocket ğ›¼ ï¼š

- $f0_0$ / $f0_1$  
- $f1_0$ / $f1_1$
- $f2_0$ / $f2_1$ 
- $f3_0$ / $f3_1$ 
- socket ğ›¼ ï¼ˆå®é™…ä¸Šå¯èƒ½æœ‰æ•°åƒä¸ªğ›¼ ç”¨äºå»¶é•¿åƒåœ¾å›æ”¶è¿‡ç¨‹ï¼Œä»¥é€ƒé¿ç¨åå°†ä»‹ç»çš„BUG_ONæ£€æŸ¥ï¼‰ã€‚

ç°åœ¨ï¼Œç¨‹åºæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

![11-operation](./picture/11-operation.png)

åœ¨è°ƒç”¨recvmsgä¹‹å‰å…³é—­ä»¥ä¸‹æ–‡ä»¶æè¿°ç¬¦ï¼Œåªç•™ä¸‹ $f2_0$ / $f2_1$ ï¼š

- close($f0_0$)
- close($f0_1$)
- close($f1_1$)
- close($f1_0$)
- close($f3_0$)
- close($f3_1$)
- close(ğ›¼)

çŠ¶æ€å¦‚ä¸‹ï¼š

- inflight($f0_0$) = N + 1, ref($f0_0$) = *N* + 1
- inflight($f0_1$) = 2, ref($f0_1$) = 2
- inflight($f1_0$) = 3, ref($f1_0$) = 3
- inflight($f1_1$) = 1, ref($f1_1$) = 1
- inflight($f2_0$) = 0, ref($f2_0$) = 1
- inflight($f2_1$) = 0, ref($f2_1$) = 1
- inflight($f3_1$) = 1, ref($f3_1$) = 1
- inflight(ğ›¼) = 1, ref(ğ›¼) = 1

å¦‚æœæ­£åœ¨è¿›è¡Œåƒåœ¾å›æ”¶è¿‡ç¨‹ï¼Œå†…æ ¸å°†è¿›è¡Œä»¥ä¸‹æ£€æŸ¥ï¼š

- å°†$f0_0$ã€$f0_1$ã€$f1_0$ã€$f1_1$ã€$f3_1$ã€ğ›¼ åˆ—ä¸ºåƒåœ¾å€™é€‰å¯¹è±¡ï¼Œå‡å°‘æ¯ä¸ªæ¥æ”¶é˜Ÿåˆ—ä¸­å€™é€‰å¯¹è±¡çš„é£è¡Œè®¡æ•°ï¼›
- ç”±äº$f2_1$ä¸è¢«è§†ä¸ºå€™é€‰è€…ï¼Œå› æ­¤$f1_1$çš„é£è¡Œè®¡æ•°ä»å¤§äºé›¶ï¼›
- é€’å½’æ¢å¤é£è¡Œè®¡æ•°ï¼›
- æ²¡æœ‰åƒåœ¾ã€‚

ä»¥ä¸‹æ“ä½œå¯èƒ½ä¼šå¼•å‘ç«äº‰ï¼Œå¹¶å¯¼è‡´ skb UAFï¼š

- ï¼ˆ1ï¼‰$f2_1$è°ƒç”¨recvmsgï¼ˆå¸¦MSG_PEEKæ ‡å¿—ï¼‰ ï¼Œè·å¾—$f1_1$'ï¼›
- ï¼ˆ2ï¼‰$f1_1$è°ƒç”¨recvmsgï¼ˆå¸¦MSG_PEEKæ ‡å¿—ï¼‰ï¼Œè·å¾—$f1_0$'ã€‚

åŒæ—¶å¹¶å‘è¿›è¡Œå¦‚ä¸‹æ“ä½œï¼š

- ï¼ˆ1ï¼‰$f1_1$è°ƒç”¨recvmsgï¼ˆä¸å¸¦MSG_PEEKæ ‡å¿—ï¼‰ï¼Œè·å¾—$f1_0$''ï¼›

- ï¼ˆ2ï¼‰$f1_0$'è°ƒç”¨recvmsgï¼ˆå¸¦MSG_PEEKæ ‡å¿—ï¼‰ã€‚

ä»¥ä¸‹ç¤ºä¾‹æ˜¯æ²¡æœ‰è§¦å‘ç«äº‰ï¼Œæ²¡æœ‰UAFçš„æƒ…å†µï¼š

| çº¿ç¨‹ 0                                                       | çº¿ç¨‹ 1                                                | çº¿ç¨‹ 2                                              |
| ------------------------------------------------------------ | ----------------------------------------------------- | --------------------------------------------------- |
| è°ƒç”¨ unix_gc                                                 |                                                       |                                                     |
| Stage0ï¼šå°†$f0_0$ã€$f0_1$ã€$f1_0$ã€$f1_1$ã€$f3_1$ã€ğ›¼åˆ—ä¸ºåƒåœ¾å€™é€‰ |                                                       |                                                     |
|                                                              | $f2_1$è°ƒç”¨recvmsgï¼ˆå¸¦MSG_PEEKæ ‡å¿—ï¼‰ ï¼Œè·å¾—$f1_1$'     |                                                     |
|                                                              | å¢åŠ å¼•ç”¨è®¡æ•°ï¼š`scm.fp = scm_fp_dup( UNIXCB (skb).fp)` |                                                     |
| Stage0ï¼šå‡å°‘æ¯ä¸ªåƒåœ¾å€™é€‰çš„é£è¡Œè®¡æ•°                           |                                                       |                                                     |
| Stage0 ä¹‹åçš„çŠ¶æ€ï¼š<br />inflight($f0_0$) = 0<br />inflight($f0_1$) = 0<br />inflight($f1_0$) = 0<br />inflight($f1_1$) = 1<br />inflight($f3_1$) = 0<br />inflight(ğ›¼) = 0 |                                                       |                                                     |
| Stage1ï¼šå¦‚æœå€™é€‰ä»æœ‰é£è¡Œè®¡æ•°ï¼Œåˆ™é€’å½’åœ°æ¢å¤å…¶é£è¡Œè®¡æ•°         |                                                       |                                                     |
| Stage1ï¼šæ‰€æœ‰é£è¡Œè®¡æ•°éƒ½å·²æ¢å¤å®Œæ¯•                             |                                                       |                                                     |
| Stage2ï¼šæ²¡æœ‰åƒåœ¾ï¼Œè¿”å›                                       |                                                       |                                                     |
|                                                              | $f1_1$è°ƒç”¨recvmsgï¼ˆå¸¦MSG_PEEKæ ‡å¿—ï¼‰ï¼Œè·å¾—$f1_0$'      |                                                     |
|                                                              |                                                       | $f1_1$è°ƒç”¨recvmsgï¼ˆä¸å¸¦MSG_PEEKæ ‡å¿—ï¼‰ï¼Œè·å¾—$f1_0$'' |
|                                                              | $f1_0$'è°ƒç”¨recvmsgï¼ˆå¸¦æœ‰MSG_PEEK æ ‡å¿—ï¼‰               |                                                     |

ä½†æ˜¯ï¼Œå¦‚æœç¬¬2æ¬¡è°ƒç”¨recvmsg å‘ç”Ÿåœ¨åƒåœ¾å›æ”¶è¿‡ç¨‹çš„Stage1ä¹‹åï¼Œåˆ™ä¼šè§¦å‘ UAFï¼š

| çº¿ç¨‹ 0                                                       | çº¿ç¨‹ 1                                                       | çº¿ç¨‹ 2                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| è°ƒç”¨ unix_gc                                                 |                                                              |                                                              |
| Stage0ï¼šå°†$f0_0$ã€$f0_1$ã€$f1_0$ã€$f1_1$ã€$f3_1$ã€ğ›¼åˆ—ä¸ºåƒåœ¾å€™é€‰ |                                                              |                                                              |
|                                                              | $f2_1$è°ƒç”¨recvmsgï¼ˆå¸¦MSG_PEEKæ ‡å¿—ï¼‰ ï¼Œè·å¾—$f1_1$'            |                                                              |
|                                                              | å¢åŠ å¼•ç”¨è®¡æ•°ï¼š`scm.fp = scm_fp_dup( UNIXCB (skb).fp)`        |                                                              |
| Stage0ï¼šå‡å°‘æ¯ä¸ªåƒåœ¾å€™é€‰çš„é£è¡Œè®¡æ•°                           |                                                              |                                                              |
| Stage0 ä¹‹åçš„çŠ¶æ€ï¼š<br />inflight($f0_0$) = 0<br />inflight($f0_1$) = 0<br />inflight($f1_0$) = 0<br />inflight($f1_1$) = 1<br />inflight($f3_1$) = 0<br />inflight(ğ›¼) = 0 |                                                              |                                                              |
| Stage1ï¼šå¦‚æœå€™é€‰ä»æœ‰é£è¡Œè®¡æ•°ï¼Œåˆ™é€’å½’åœ°æ¢å¤å…¶é£è¡Œè®¡æ•°         |                                                              |                                                              |
|                                                              | $f1_1$è°ƒç”¨recvmsgï¼ˆå¸¦MSG_PEEKæ ‡å¿—ï¼‰ï¼Œè·å¾—$f1_0$'             |                                                              |
|                                                              |                                                              | $f1_1$è°ƒç”¨recvmsgï¼ˆä¸å¸¦MSG_PEEKæ ‡å¿—ï¼‰ï¼Œè·å¾—$f1_0$''          |
|                                                              |                                                              | `unix_detach_fds()` : `UNIXCB (skb).fp = NULL` **æ¸…ç©º$f1_1$çš„æ¥æ”¶é˜Ÿåˆ—** |
|                                                              |                                                              | `spin_lock(&unix_gc_lock)` é˜»å¡                              |
| Stage1ï¼š**[scan_inflight()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L96) æ— æ³•ä»$f1_1$ çš„æ¥æ”¶é˜Ÿåˆ—ä¸­æ‰¾åˆ°å€™é€‰socketï¼Œæ— æ³•æ¢å¤é£è¡Œè®¡æ•°ã€‚å› æ­¤ï¼Œé£è¡Œè®¡æ•°æ„å¤–åœ°ä¿æŒä¸å˜ã€‚é£è¡Œè®¡æ•°ç­‰äº0åˆ™ä¸ä¼šå°†å…¶ä»`gc_candidates`åˆ—è¡¨ä¸­ç§»é™¤ï¼Œ`gc_candidates`åˆ—è¡¨ä¸­éƒ½ä¼šè¢«å½“ä½œåƒåœ¾ã€‚** |                                                              |                                                              |
| Stage2: $f0_0$, $f0_1$, $f1_0$, $f3_1$, ğ›¼ æ˜¯åƒåœ¾ã€‚           |                                                              |                                                              |
| Stage2ï¼šå¼€å§‹æ¸…é™¤åƒåœ¾ã€‚                                       |                                                              |                                                              |
|                                                              | $f1_0$'è°ƒç”¨recvmsgï¼ˆå¸¦æœ‰MSG_PEEK æ ‡å¿—ï¼‰ï¼Œé¢„è®¡ä¼šæ”¶åˆ° $f0_0$'  |                                                              |
|                                                              | è·å¾— `skb = skb_peek(&sk->sk_receive_queue)`ï¼Œskb å°†è¢«çº¿ç¨‹ 0 é‡Šæ”¾ã€‚ |                                                              |
| Stage2ï¼šå¯¹äº$f1_0 \rightarrow \begin{bmatrix} \sum_{0}^N f0_0 \end{bmatrix} \rightarrow f1_0$ï¼Œç¨åè°ƒç”¨ [__skb_unlink()](https://elixir.bootlin.com/linux/v4.14.277/source/include/linux/skbuff.h#L1908) å’Œ [kfree_skb()](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/skbuff.c#L666) |                                                              |                                                              |
|                                                              | `state->recv_actor(skb, skip, chunk, state)` UAF             |                                                              |
| GC å®Œæˆ                                                      |                                                              |                                                              |
|                                                              |                                                              | å¼€å§‹åƒåœ¾å›æ”¶                                                 |
|                                                              |                                                              | è·å– $f1_0$''                                                |

å› æ­¤ï¼Œç«äº‰ä¼šå¯¼è‡´ skb å¯¹è±¡çš„ UAFã€‚ä¹ä¸€çœ‹ï¼Œé—®é¢˜åœ¨äºç¬¬2æ¬¡è°ƒç”¨recvmsg æ—¶æ¸…ç©ºäº†`skb.fp`ï¼Œä¹Ÿå³ä¼ é€’çš„æ–‡ä»¶åˆ—è¡¨ã€‚ ä½†å¦‚æœç¬¬1æ¬¡è°ƒç”¨ recvmsg æ—¶æ²¡æœ‰è®¾ç½® MSG_PEEK æ ‡å¿—ï¼Œå°±å¯ä»¥é¿å… UAFï¼Œå› ä¸º [unix_notinflight()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L67) æ˜¯é€šè¿‡åƒåœ¾å›æ”¶åºåˆ—åŒ–çš„ã€‚**å†…æ ¸åº”å½“å¼•å…¥æ­£ç¡®çš„åŒæ­¥æœºåˆ¶ï¼Œåœ¨å‡å°‘é£è¡Œè®¡æ•°å’Œåˆ é™¤ skb ä¹‹å‰å¿…é¡»ç¡®ä¿æ²¡æœ‰æ­£åœ¨å¤„ç†çš„åƒåœ¾å›æ”¶è¿‡ç¨‹**ã€‚è¿™æ ·åœ¨ [unix_notinflight()](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L67) ä¹‹åï¼Œreceiver è·å¾— $f1_1$' å¹¶ä¸”é£è¡Œsocketä¸ä¼šå½¢æˆä¸å¯ç ´çš„å¾ªç¯ã€‚

ç”±äº MSG_PEEK æœªé€šè¿‡åƒåœ¾å›æ”¶è¿›è¡Œåºåˆ—åŒ–ï¼Œå› æ­¤å½“è°ƒç”¨recvmsgï¼ˆå¸¦MSG_PEEKæ ‡å¿—ï¼‰æ—¶ ï¼Œå†…æ ¸ä»å°† $f1_1$ è§†ä¸ºåƒåœ¾å€™é€‰å¯¹è±¡ï¼Œè¿™æ ·ä¸‹ä¸€æ¬¡è°ƒç”¨ recvmsg æ—¶ä¼šå› ä¸ºåƒåœ¾å›æ”¶è¿‡ç¨‹çš„çŠ¶æ€ä¸ä¸€è‡´è€Œè§¦å‘è¯¥æ¼æ´ã€‚

## 3. è¡¥ä¸åˆ†æ

**æ¼æ´å‘ç°**ï¼šåœ¨2016å¹´å°±æœ‰ç ”ç©¶äººå‘˜å°†è¯¥æ¼æ´æŠ¥ç»™å†…æ ¸ç¤¾åŒºï¼ˆå‚è§[é“¾æ¥](https://patchwork.ozlabs.org/project/netdev/patch/CAOssrKcfncAYsQWkfLGFgoOxAQJVT2hYVWdBA6Cw7hhO8RJ_wQ@mail.gmail.com/)ï¼‰ï¼Œå¹¶ç»™å‡ºæ­£ç¡®çš„è¡¥ä¸å»ºè®®ï¼Œä½†æœªè¢« Linux å†…æ ¸ç¤¾åŒºæ¥å—ã€‚

Linux å†…æ ¸å¼€å‘äººå‘˜ï¼šä¸ºä»€ä¹ˆæˆ‘è¦åº”ç”¨ä¸€ä¸ª RFC è¡¥ä¸ï¼Œæ²¡æœ‰æ­£ç¡®çš„æäº¤æ¶ˆæ¯ï¼Œæ²¡æœ‰æ­£ç¡®çš„ç­¾ç½²ï¼Œä¹Ÿæ²¡æœ‰æ¥è‡ªå…¶ä»–çŸ¥è¯†æ¸Šåšçš„å¼€å‘äººå‘˜çš„ ACK å’Œåé¦ˆï¼Ÿ

![12-2016-patch](./picture/12-2016-patch.png)

**2021å¹´å®˜æ–¹è¡¥ä¸**ï¼šå‚è§CVE-2021-0920çš„å®˜æ–¹[patch](https://lore.kernel.org/lkml/20210802134333.066918619@linuxfoundation.org/)ã€‚å¯¹äº `MSG_PEEK` åˆ†æ”¯ï¼Œåœ¨æ‰§è¡Œæ•æ„Ÿæ“ä½œä¹‹å‰è¯·æ±‚åƒåœ¾å›æ”¶é” `unix_gc_lock` å¹¶ä¸”ç”¨å®Œåç«‹å³é‡Šæ”¾ã€‚è½¯ä»¶å¼€å‘ä¸­å¾ˆå°‘è§åˆ°è¿™æ ·çš„é”ç”¨æ³•ã€‚

```c
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -1507,6 +1507,53 @@ out:
 	return err;
 }
 
+static void unix_peek_fds(struct scm_cookie *scm, struct sk_buff *skb)
+{
+	scm->fp = scm_fp_dup(UNIXCB(skb).fp);
+
+	spin_lock(&unix_gc_lock);
+	spin_unlock(&unix_gc_lock);
+}
+
 static int unix_scm_to_skb(struct scm_cookie *scm, struct sk_buff *skb, bool send_fds)
 {
 	int err = 0;
@@ -2140,7 +2187,7 @@ static int unix_dgram_recvmsg(struct soc
 		sk_peek_offset_fwd(sk, size);
 
 		if (UNIXCB(skb).fp)
-			scm.fp = scm_fp_dup(UNIXCB(skb).fp);
+			unix_peek_fds(&scm, skb);
 	}
 	err = (flags & MSG_TRUNC) ? skb->len - skip : size;
 
@@ -2385,7 +2432,7 @@ unlock:
 			/* It is questionable, see note in unix_dgram_recvmsg.
 			 */
 			if (UNIXCB(skb).fp)
-				scm.fp = scm_fp_dup(UNIXCB(skb).fp);
+				unix_peek_fds(&scm, skb);
 
 			sk_peek_offset_fwd(sk, chunk);
```

**`BUG_ON` 2017è¡¥ä¸**ï¼šæ¥è‡ª Google çš„ Andrey Ulanov äº 2017 å¹´åœ¨unix_gcä¸­å‘ç°äº†å¦ä¸€ä¸ªæ¼æ´å¹¶æäº¤äº†[patch](https://lore.kernel.org/lkml/20170315031642.19576-1-andreyu@google.com/)ã€‚æ­¤å¤–ï¼Œè¯¥è¡¥ä¸è¿˜ä¸ºé£è¡Œè®¡æ•°æ·»åŠ äº†`BUG_ON()`ã€‚

ä¹ä¸€çœ‹ï¼Œä¼¼ä¹ `BUG_ON()` å¯ä»¥é˜»æ­¢ CVE- 2021-0920 è¢«åˆ©ç”¨ã€‚ä½†æ˜¯ï¼Œå¦‚æœé€šè¿‡åˆ¶é€ å¤§é‡å‡åƒåœ¾æ¥å»¶è¿Ÿåƒåœ¾å›æ”¶ï¼Œåˆ©ç”¨å †å–·å°„æ¥é¿å… `BUG_ON()` æ£€æŸ¥ã€‚

```c
diff --git a/net/unix/garbage.c b/net/unix/garbage.c
index 6a0d48525fcf..c36757e72844 100644
--- a/net/unix/garbage.c
+++ b/net/unix/garbage.c
@@ -146,6 +146,7 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
 
+		BUG_ON(!atomic_long_read(&u->inflight));
 		BUG_ON(list_empty(&u->link));
 
 		if (atomic_long_dec_and_test(&u->inflight))
```

**CVE-2021-4083**ï¼šåœ¨ä½œè€…ä¸ Jann Horn å’Œ Ben Hawkesè®¨è®ºCVE-2021-0920 æ—¶ï¼ŒJann åœ¨åƒåœ¾å›æ”¶ä¸­å‘ç°äº†å¦ä¸€ä¸ªæ¼æ´ï¼Œå‚è§ [Racing against the clock -- hitting a tiny kernel race window](https://googleprojectzero.blogspot.com/2022/03/racing-against-clock-hitting-tiny.html)ã€‚

## å‚è€ƒ

[The quantum state of Linux kernel garbage collection CVE-2021-0920 (Part I)](https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html) 

[CVE-2021-0920: Android sk_buff use-after-free in Linux](https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2021/CVE-2021-0920.html)

[io_uring, SCM_RIGHTS, and reference-count cycles](https://lwn.net/Articles/779472/)
